dupenet MVP ‚Äî Progress Overview
================================

PHASE 1: BLOB UTILITY (Layer A)
--------------------------------

## Step 1 ‚Äî File Layer + Gateway + HTTP Origin

[x] Canonical serialization          deterministic CBOR, sorted keys (packages/physics)
[x] CID computation                  SHA256-based content addressing
[x] Chunker                          256KiB blocks, reassembly
[x] Merkle tree                      binary merkle, odd-leaf promotion
[x] FileManifestV1 schema            TypeBox schema (chunk_size, size, blocks[], merkle_root)
[x] AssetRootV1 schema               TypeBox schema (kind, original, variants, meta)
[x] PricingV1 schema                 min_request_sats, sats_per_gb, burst
[x] Block storage backend            filesystem: {base}/{h[0:2]}/{h[2:4]}/{hash}
[x] PUT /block/:cid                  SHA256 verified on receive, rejects mismatches
[x] GET /block/:cid                  serves bytes; L402-gated when LND configured, free in dev mode
[x] PUT /file/:root                  validates file_root = SHA256(canonical(manifest)), checks all blocks exist
[x] GET /file/:root                  returns manifest (persisted to disk via MetadataStore)
[x] PUT /asset/:root                 validates asset_root = SHA256(canonical(AssetRoot)), checks file exists
[x] GET /asset/:root                 returns asset (persisted to disk via MetadataStore)
[x] HEAD /asset/:root                returns size, kind, mime headers
[x] GET /pricing                     returns PricingV1
[x] GET /health                      gateway health check
[x] Physics unit tests               canonical, cid, chunker, merkle, reward, epoch-aggregation, availability, block-selection, event-signature (9 suites, vitest)
[x] Gateway integration test          PUT /block xN -> PUT /file -> PUT /asset -> GET -> reassemble -> verify (7 tests)
[ ] EXIF/metadata stripping           strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation         TypeBox schemas defined but Value.Check not called on ingest

## Step 2 ‚Äî L402 Paid Fetch + Receipt Minting

[x] Mint service structure            POST /sign, GET /pubkey, GET /health (apps/mint)
[x] Ed25519 keypair load              loads from MINT_PRIVATE_KEY_HEX env var
[x] Receipt token format              Sign("R2" || host || epoch || block_cid || response_hash || price || payment_hash)
[x] LND service in docker compose     lnd v0.18.5-beta + bitcoind regtest, 2-node (alice+bob) in compose-founder.yml
[x] LND config fields                 LND_HOST, LND_MACAROON_PATH, LND_TLS_CERT_PATH in gateway + mint config
[x] LND client package                packages/lnd-client: LndClient interface, REST impl, MockLndClient for tests
[x] L402 challenge-response           GET /block returns 402 + invoice -> pay with preimage -> bytes + receipt_token
[x] Invoice store                     in-memory TTL map (payment_hash -> {cid, price, host, epoch, expiry})
[x] Invoice generation                gateway creates invoice via LndClient.createInvoice()
[x] Mint settlement check             mint calls LndClient.lookupInvoice(), verifies SETTLED + amount >= price
[x] Mint HTTP client                  gateway calls POST /sign on mint, receives receipt_token
[x] min_request_sats enforcement      price = min_request_sats used for all block fetches
[x] L402 integration tests            8 tests: 402 challenge, paid fetch, invalid/unknown/mismatch/single-use (mock LND)
[x] Client PoW receipt minting        minePoW(), buildChallengeRaw/ClientSigPayload/TokenPayload in physics
[x] Block selection (anti-special)    selectBlockIndex(), selectBlock(), verifyBlockSelection() in physics (SHA256 PRF)

## Step 3 ‚Äî Node Kit + Host Registration

[x] compose-founder.yml               gateway, mint, coordinator, postgres, lnd, caddy (all with healthchecks)
[x] compose-nodekit.yml               gateway, node-agent, caddy
[x] Coordinator structure             Hono server with routes, event log, materialized views
[x] POST /host/register               registers host (stub stake verification)
[x] GET /directory                     returns host list from in-memory Map
[x] Node-agent poll loop                discover profitable CIDs ‚Üí mirror from source ‚Üí announce serve (complete)
[x] Mirror agent                       findProfitableTargets() queries GET /bounty/feed; mirrorCid() fetches + pushes
[x] Directory announcement             announceHost() signed registration; announceServe() signed HostServe
[x] Availability score tracking        computeAvailabilityScore() in physics + updateAllScores() in coordinator
[x] Status lifecycle                   PENDING->TRUSTED (score>=0.6), TRUSTED->DEGRADED (score<0.6), ->INACTIVE (score==0)
[x] Spot-check responder              GET /spot-check/:cid on gateway (verifies hash, no L402, no bytes)
[x] Spot-check runner                 spotCheckHost(), runAllChecks() in coordinator (injectable fetcher)
[x] SpotCheck Prisma model            hostPubkey, cid, epoch, passed, latencyMs, error
[x] POST /hosts/check                 triggers spot-checks for all active hosts, updates scores
[x] GET /hosts/:pubkey/checks         returns check history + availability score + recommended status
[x] Availability tests                9 physics + 12 coordinator tests (scoring, transitions, spot-check runner)
[ ] Stake locking via LND              TODO: verify stake payment
[x] CID selection agent                queries GET /bounty/feed, filters by minBounty, mirrors top profitability CIDs

## Step 4 ‚Äî Receipt Verification SDK

[x] VerifyReceiptV2 function           packages/receipt-sdk, full verification logic
[x] Ed25519 verify                     Web Crypto API, zero dependencies
[x] PoW hash check                     H(challenge || nonce) < TARGET validation
[x] Client signature check             Ed25519 sig over receipt payload
[x] Zero external dependencies         only crypto.subtle
[x] Test vectors                       valid e2e receipt (construct -> verify), invalid hex/PoW/token, wrong mint key (7 tests)

## Step 5 ‚Äî Pin Contracts

[x] PinContractV1 schema               TypeBox schema (physics) + Prisma model
[x] POST /pin                           creates pin, computes drain_rate, credits bounty pool, logs event
[x] GET /pin/:id                        returns status, remaining budget, active hosts, copies_met, epoch proofs
[x] POST /pin/:id/cancel               returns remaining budget minus 5% fee, status -> CANCELLED
[x] Drain rate enforcement              drainPinBudgets() deducts min(actualDrain, drainRate) per epoch
[x] Budget management                   creditBountyDirect (no protocol fee); debitPayout on cancel refund
[x] Lifecycle transitions               ACTIVE -> EXHAUSTED (when remainingBudget=0); ACTIVE -> CANCELLED (on cancel)
[x] min_copies check                    getPinStatus compares active hosts vs min_copies, returns copies_met
[x] Epoch proof bundle                  getPinStatus returns recent EpochSummaryRecords for pinned asset (last 6 epochs)
[x] Pin contract tests                  22 tests: validation, create, status, cancel, drain rate, exhaustion
[x] Pin ID deterministic                SHA256(canonical(pin content)) ‚Äî duplicate detection via unique constraint

COORDINATOR ‚Äî PERSISTENCE + AGGREGATION
-----------------------------------------

[x] Prisma schema                      Event, BountyPool, Host, HostServe, EpochSummaryRecord, PinContract
[x] Prisma client generated            in Dockerfile (npx prisma generate)
[x] POST /tip                          credits bounty pool (in-memory Map, stub sig verification)
[x] GET /bounty/:cid                   reads from in-memory Map
[x] Event log writer                   in-memory array (not persisted)
[x] Bounty pool view                   in-memory Map
[x] Host registry view                 in-memory Map
[x] Epoch math                         packages/physics: epoch length 4h, current epoch, epoch boundaries
[x] Reward formulas                    cidEpochCap, computeHostScore, distributeRewards (physics)
[x] EpochSummary schema                defined in physics
[x] Coordinator -> Postgres             bounty-pool, host-registry, event-log all use PrismaClient (tsc clean)
[x] Event log persistence               append-only Postgres via prisma.event.create
[x] POST /receipt/submit                validates via receipt-sdk, checks epoch range + replay, stores in Prisma
[x] Receipt validation pipeline         verifyReceiptV2 checks client_sig, PoW, receipt_token against mint pubkeys
[x] Epoch aggregation (physics)         aggregateReceipts(), isPayoutEligible(), computePayoutWeight()
    - smooth payout_weight: totalProvenSats * (1 + log2(uniqueClients))
    - isPayoutEligible: receipt_count >= 1 AND totalProvenSats > 0
[x] Epoch settlement (coordinator)      settleEpoch() ‚Äî aggregate receipts, compute payouts, drain bounty, persist EpochSummary
[x] POST /epoch/settle                  validates epoch is closed, calls settleEpoch(), idempotent (no double-spend)
[x] GET /epoch/summary/:epoch           returns settlement results for a given epoch
[x] Payout execution                    distributeRewards() called by settleEpoch(), rewards split by host score
[x] Bounty drain                        cidEpochCap() limits per-epoch drain, debitPayout() debits pool
[x] Aggregator fee                      3% deducted from cap before host distribution
[x] Egress royalty                      1% of proven L402 egress, deducted at settlement
[x] Auto-bids in settlement            2% of proven egress auto-credited to pool (with royalty)
[x] Epoch settlement tests              15 coordinator tests (mock Prisma) + 30 physics aggregation tests
[x] Epoch boundary trigger              createEpochScheduler() auto-settles closed epochs; configurable interval + spot-checks
[x] Signature verification on events    Ed25519 verify on POST /tip and POST /host/register; rejects forged/missing sigs

DOCKER / DEPLOY
-----------------

[x] compose-founder.yml                bitcoind + lnd-alice + lnd-bob + gateway + mint + coordinator + postgres + caddy
[x] compose-nodekit.yml                gateway + node-agent + caddy (separate Caddyfile)
[x] Dockerfiles (4 apps)               multi-stage node:20-alpine builds (gateway, mint, coordinator, node-agent)
[x] Coordinator entrypoint             prisma db push --skip-generate on startup (idempotent)
[x] LND credential sharing             lnd-data volume mounted read-only to gateway + mint
[x] LND REST wiring                    gateway + mint create LndRestClient when macaroon exists (dev mode fallback)
[x] @noble/ed25519 sha512 setup        mint signer configures sha512Sync from @noble/hashes
[x] Caddyfile.founder                  gateway + coordinator routes (/spot-check, /epoch, /hosts added)
[x] Caddyfile.nodekit                  gateway-only routes
[x] scripts/gen-keys.sh                generates Ed25519 keypairs (host + 3 mints), writes .env.local
[x] scripts/fund-lnd.sh                funds alice + bob, opens 1M sat channel
[x] scripts/e2e.sh                     E2E test skeleton (needs polish for receipt/settle path)
[x] Startup config echo                all 4 apps print config on boot (port, LND mode, mint keys, genesis)
[x] GENESIS_TIMESTAMP_MS env var       coordinator + gateway; enables epoch boundary control for testing
[x] @types/node for Docker builds      physics + receipt-sdk; fixes Web Crypto type errors in Docker context
[x] Buffer.slice() fix (ed25519)       wcBuf() helper handles cbor-x Buffer views correctly

INTEGRATION / E2E
------------------

[x] Gateway round-trip test             upload multi-block file, retrieve by asset_root, verify SHA256 (7 tests)
[x] L402 flow test                      402 -> pay invoice -> receive block + receipt_token (8 tests, mock LND)
[x] Docker E2E                          FULL PASS: upload ‚Üí 402 ‚Üí bob pays ‚Üí block + receipt_token ‚Üí tip ‚Üí receipt submit ‚Üí epoch settle ‚úì
[x] Receipt round-trip test             construct valid receipt (PoW + mint sig + client sig) -> verifyReceiptV2 passes
[x] Epoch settlement test              mock Prisma: eligible/ineligible hosts, bounty drain, idempotency, score split
[x] Pin contract test                  mock Prisma: create/status/cancel, drain rate, exhaustion, validation (22 tests)
[x] Availability test                  mock Prisma + mock fetcher: spot-check, scoring, transitions (12 tests)
[x] Event signature test               real Ed25519 keypairs: signed tip/register accepted, forged/missing rejected (7 tests)
[x] Bounty feed + host/serve test     bounty feed returns profitable CIDs; signed serve announcements (6 tests)
[x] Node-agent poll cycle test        mock fetch: discover, mirror, error handling (6 tests)
[x] Epoch scheduler test             mock Prisma: tick settles, idempotent, start/stop, error handling (7 tests)

SPRINT ORDER (Phase 1 ‚Äî complete)
-----------------------------------

1. Gateway integration tests            DONE (7 tests pass)
2. L402 + mint settlement               DONE (8 tests pass, mock LND; Docker E2E with real LND in sprint 6)
3. Coordinator -> Postgres              DONE (tsc clean; requires `prisma db push` + Postgres to run)
4a. Receipt submission + validation     DONE (receipt-sdk e2e test passes; coordinator handler typechecks)
4b. Epoch aggregation + payout          DONE (20 new tests: 12 physics + 8 coordinator; bounty drains correctly)
5. Pin contracts lifecycle              DONE (22 new tests; create, cancel, drain rate, exhaustion all work)
6. Docker E2E                           DONE ‚Äî full pipeline: upload ‚Üí L402 paid fetch ‚Üí tip ‚Üí receipt submit ‚Üí epoch settle


================================================================================
DIVERGENCES (code vs mvp_plan.md ‚Äî fix before or during Sprint 7b)
================================================================================

Audit date: 2026-02-09. Cross-referenced all completed code against MVP plan spec.

## Fee Model ‚Äî FIXED

[x] Volume-tapering founder royalty     replaced flat 5% (TIP_PROTOCOL_FEE_PCT) with r(v) formula
    - packages/physics/src/royalty.ts: founderRoyaltyRate(), computeRoyalty(), cumulativeFounderIncome()
    - apps/coordinator/src/views/bounty-pool.ts: creditTip() now queries cumulative volume, applies formula
    - constants.ts: FOUNDER_ROYALTY_R0=0.15, V_STAR=125M, ALPHA=log(2)/log(9)
    - removed: TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
    - 170/170 tests pass

## Pool Key (blocks event/topic funding)

## Pool Key (blocks event/topic funding) ‚Äî FIXED

[x] BountyPool keyed by generic bytes32
    - Prisma BountyPool.poolKey: String @id @map("cid") ‚Äî no DB migration needed
    - All routes, views, tests updated to use poolKey
    - Accepts CID, event_id, or topic hash

## Gateway Endpoints ‚Äî FIXED

[x] GET /cid/{hash} unified endpoint
    - apps/gateway/src/routes/cid.ts: if asset ‚Üí 302 /asset/; if file ‚Üí 302 /file/; if block ‚Üí serve bytes

[x] Free preview tier
    - blocks ‚â§ FREE_PREVIEW_MAX_BYTES (16 KiB) served without L402
    - configurable: FREE_PREVIEW_ENABLED env var (default true)
    - per-IP rate limiting deferred (sufficient for founder scale)

## PricingV1 Schema ‚Äî FIXED

[x] PricingV1 now has all 6 fields   burst_sats_per_gb, min_bounty_sats, sats_per_gb_month, open_min_pool_sats
    - packages/physics/src/schemas/host.ts: 4 new Optional() fields added
    - all backward-compatible (existing 2-field PricingV1 still valid)

## Constants ‚Äî MOSTLY FIXED

[x] Stale constants removed            TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
[x] Royalty constants added             FOUNDER_ROYALTY_R0, V_STAR, ALPHA
[x] PricingV1 constants added          BURST_SATS_PER_GB, MIN_BOUNTY_SATS_DEFAULT, OPEN_MIN_POOL_SATS_DEFAULT
[x] Event constants added              EVENT_POW_TARGET, EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES
[x] AGGREGATOR_FEE_PCT added to plan   MVP default (3%), market-determined post-MVP

Plan constants still missing from code (add during relevant sprint):
    - BASE_FEE = 21-210 sats                  ‚Üí Sprint 7b (EventV1 ingest, dynamic pricing)
    - SNAPSHOT_INTERVAL_EPOCHS = 100          ‚Üí Sprint 7d.1
    - ANCHOR_INTERVAL_EPOCHS = 6             ‚Üí Sprint 7d.1
    - PREVIEW_THUMB_WIDTH = 200              ‚Üí Sprint 7e
    - PREVIEW_TEXT_CHARS = 500               ‚Üí Sprint 7e

## Schema Gaps (non-blocking, fix during relevant sprint)

[ ] EpochSummary missing receipt_merkle_root    ‚Üí Sprint 7d.1 (snapshot/compaction)
[ ] DirectoryV1 missing regions[], refusals_cid, materializers[]  ‚Üí Sprint 7b
[ ] No MaterializerV1 / MaterializerPricingV1 schema  ‚Üí Sprint 7b
[x] EventV1 TypeBox schema                       DONE ‚Äî packages/physics/src/schemas/event.ts
[ ] Pin cancel: no SLA-triggered fee waiver    ‚Üí Sprint 7b (needs SLA monitoring)
[ ] GET /served endpoint missing               ‚Üí Sprint 7b (low priority)
[x] Node-agent publishes min_bounty_sats       DONE ‚Äî announce.ts includes full PricingV1

## False Positive in Progress Log ‚Äî FIXED

[x] sats_per_gb_month now in TypeBox schema (host.ts) as Optional field. Progress log corrected.

## Codebase Review Fixes (2026-02-09)

[x] Bug: INACTIVE‚ÜíTRUSTED transition   host-registry.ts ‚Äî INACTIVE hosts that recover now transition back
[x] Bug: mirror multi-block assets     node-agent/mirror.ts ‚Äî resolves AssetRoot‚ÜíManifest‚Üíblocks (was single-block only)
[x] Bug: mint input validation         mint/server.ts ‚Äî POST /sign now validates all 6 fields (was crashing on undefined)
[x] Bug: invoice store leak            gateway/server.ts ‚Äî cleanup() now called every 60s via setInterval + onClose hook
[x] Dead code: satsPerGb passthrough   gateway/routes/block.ts ‚Äî removed from BlockRouteContext (flat minRequestSats is correct)
[x] Test: royalty.ts coverage          16 new tests: formula at plan anchor points, monotonicity, edge cases, input guards
[x] Test: availability transition      fixed test expectation: score=0 ‚Üí INACTIVE (not DEGRADED) per plan lifecycle
    Total after review fixes: 186/186 tests pass (was 170)

## Sprint 7b Implementation (2026-02-09)

[x] EventV1 schema + sign/verify      packages/physics: EventV1 TypeBox, event-v1.ts (sign, verify, eventId, body encode/decode)
[x] Kind constants + payloads         9 kind bytes (FUND..MATERIALIZER) + AnnouncePayload, HostPayload, ListPayload, PinPayload
[x] POST /event endpoint              coordinator: unified event ingest, sig verify, pool credit, kind=HOST side effect
[x] Pool key generalization           Prisma BountyPool.poolKey (@map("cid")), all views + tests updated
[x] GET /cid/:hash endpoint           gateway: unified resolve (asset‚Üí302, file‚Üí302, block‚Üíserve)
[x] Free preview tier                 gateway: blocks ‚â§16 KiB served without L402 (configurable)
[x] Node-agent min_bounty_sats       announce.ts: publishes full PricingV1 with min_bounty_sats + open_min_pool_sats
[x] 24 new EventV1 tests             event-v1.test.ts: construct, sign, verify, event_id, body, kind constants, lifecycle
    Total after Sprint 7b: 203/203 tests pass (was 186)

## Sprint 7d Implementation (2026-02-09)

[x] ProtocolEvent Prisma model        indexed materializer view: event_id (unique), (ref), (kind,ts), (from,ts)
[x] POST /event ‚Üí ProtocolEvent       events now stored in both generic log + indexed ProtocolEvent table
[x] GET /events query                  generic event query: filter by ref, kind, from, since; paginated
[x] GET /feed/funded                   pool keys ranked by balance + ANNOUNCE metadata from ProtocolEvent
[x] GET /feed/recent                   recent ANNOUNCE events, decoded metadata, tag filter, pagination
[x] GET /thread/:event_id             recursive ref-chain resolution into tree (depth-limited)
[x] materializer.ts view module       storeProtocolEvent, queryEvents, feedFunded, feedRecent, getThread
[x] 18 new materializer tests         materializer.test.ts: POST‚Üístore, events query, funded/recent feeds, thread tree
    Total after Sprint 7d: 221/221 tests pass (was 203)

## Sprint 7e Implementation (2026-02-09)

[x] Next.js 15 scaffold               apps/web: App Router, server components, no client JS
    - package.json, tsconfig.json, next.config.js, globals.css
    - craigslist aesthetic: monospace, no styling, symbols/numbers only
[x] API client                        src/lib/api.ts: all coordinator fetches + formatting helpers
[x] / Leaderboard                     table: #, sat, hosts, title, proof ‚Äî from GET /feed/funded
[x] /v/[ref] Content                  metadata + stats + thread ‚Äî from GET /events + /bounty + /thread
[x] /c/[ref] Collection               list items with per-item pool balances ‚Äî from GET /events + /bounty
[x] /p/[ref] Proof                    hash, pool, hosts, epoch proofs ‚Äî from /bounty + /directory + /epoch/summary
    Total: 228/228 tests pass + Next.js build clean (4 pages + 3 API routes, server + client components)

## Sprint 7c Implementation (2026-02-09)

[x] dupenet fund <ref> <sats>         apps/cli/src/commands/fund.ts ‚Äî POST /event kind=FUND
[x] dupenet post <ref> <text>         apps/cli/src/commands/post.ts ‚Äî POST /event kind=POST, --sats flag
[x] dupenet upload + ANNOUNCE         upload.ts now emits ANNOUNCE event with --title/--tags/--access
    Total: 221/221 tests pass + CLI tsc clean + Next.js build clean

## Economics Rework Implementation (2026-02-10)

[x] Smooth payout multiplier          epoch-aggregation.ts: computePayoutWeight(), updated isPayoutEligible()
[x] Egress royalty (1%)               royalty.ts: computeEgressRoyalty(), settlement deduction
[x] Multiplicative host score         reward.ts: payoutWeight √ó (W_UPTIME √ó uptime + W_DIVERSITY √ó diversity)
[x] Settlement egress tracking        epoch-settlement.ts: totalEgressRoyaltySats, totalProvenEgressSats
    Total: 228/228 tests pass (was 203, +25 new economics tests)

## Auto-Bid System Implementation (2026-02-10)

[x] Auto-bid constants                constants.ts: AUTO_BID_PCT=0.02, CLEARING_SPREAD_PCT=0.03, preserve tiers
[x] Auto-bid physics module           auto-bid.ts: computeAutoBid, computeEpochAutoBids, sustainabilityRatio
[x] Settlement integration            epoch-settlement.ts: auto-bids computed + credited after rewards
[x] Prisma schema update              EpochSummaryRecord: autoBidSats, egressRoyaltySats fields
[x] Physics tests (28 new)            auto-bid.test.ts: single/multi-CID, rounding, sustainability
[x] Coordinator tests (7 new)         epoch-settlement.test.ts: auto-bid credits, royalty, event log
    Total: 293/293 tests pass + Next.js build clean (was 228)


================================================================================
PATH A: DEPLOY + CLI (get content flowing)
================================================================================

Goal: founder can upload seed content, share links, people can fetch via L402.
DocRef: MVP_PLAN:¬ßBootstrap Sequence (Week 1-2), ¬ßWhat Layer A Markets Need

## Sprint 7 ‚Äî CLI client (apps/cli)

The minimum tool for a human to use the protocol without curl.
Wraps the HTTP API into a command-line workflow.

[x] Project scaffold                    apps/cli, TypeScript, imports @dupenet/physics, commander
[x] `dupenet upload <file>`             chunk ‚Üí PUT /block √ó N ‚Üí PUT /file ‚Üí PUT /asset ‚Üí print asset_root
    - chunker + manifest + asset root construction (reuse physics)
    - multi-block upload with progress indicator
    - MIME auto-detect from extension, auto kind (TEXT/IMAGE/AUDIO/VIDEO/FILE)
    - print shareable URL: https://<gateway>/asset/<root>
[x] `dupenet fetch <cid> [-o file]`     GET /asset ‚Üí GET /file ‚Üí stream GET /block √ó N ‚Üí reassemble ‚Üí write
    - auto-detect: raw CID (single block) vs asset_root (multi-block)
    - L402 flow: get 402 ‚Üí pay invoice via LND REST ‚Üí present preimage ‚Üí receive bytes
    - --free flag fails instead of paying (for dev mode gateways)
    - SHA256 integrity verification on reassembly
[x] `dupenet tip <cid> <sats>`          sign tip ‚Üí POST /tip ‚Üí print bounty balance
    - Ed25519 sign from local keyfile (~/.dupenet/key.json)
    - print pool_credit + protocol_fee
[x] `dupenet pin create <asset_root>`   POST /pin ‚Üí print pin_id, drain_rate
    - --budget, --duration, --copies flags
    - `dupenet pin status <pin_id>` ‚Üí GET /pin/:id
    - `dupenet pin cancel <pin_id>` ‚Üí POST /pin/:id/cancel
[x] `dupenet info <cid>`                GET /bounty/:cid + GET /asset/:root ‚Üí print summary
    - bounty balance, asset metadata, gateway pricing
[x] `dupenet keygen`                    generate Ed25519 keypair ‚Üí write to ~/.dupenet/key.json
    - reuse physics generateKeypair()
    - --force to overwrite existing
    - print pubkey hex
[x] `dupenet config`                    gateway URL, coordinator URL, key path, LND connection
    - ~/.dupenet/config.json
    - env var overrides (DUPENET_GATEWAY, DUPENET_COORDINATOR, DUPENET_KEY_PATH)
[x] `dupenet hosts`                     GET /directory ‚Üí print host list + pricing + status
[x] LND payment integration             pay L402 invoices via LND REST (/v2/router/send)
    - connect to user's LND (REST, macaroon auth)
    - fallback: print invoice + prompt for manual wallet payment

Exit: `dupenet upload cat.jpg` ‚Üí prints asset_root URL ‚Üí `dupenet fetch <root> -o out.jpg` ‚Üí identical file.
      `dupenet tip <root> 100` ‚Üí bounty pool credited.

## Sprint 8 ‚Äî Real deployment (founder stack on VPS)

The founder stack moves from Docker-on-laptop to a public server.
DocRef: MVP_PLAN:¬ßNode Kit, ¬ßWhat Hosts vs What You Host, ¬ßBootstrap Sequence, ¬ßInfrastructure Partners

[x] VPS provisioning                    FlokiNET Romania (4 CPU, 4GB RAM, 90GB NVMe, 9TB BW, DDoS prot.)
[x] Domain acquired                     ocdn.is (ISNIC Iceland ‚Äî ccTLD, seizure-proof, WHOIS privacy)
[x] DNS A record                        ocdn.is ‚Üí 185.165.169.8 (live, propagated)
[x] compose-production.yml              signet LND (neutrino), hardened Postgres, restart policies, 0.0.0.0 binding
[x] Caddyfile.production                ocdn.is domain, automatic HTTPS via Caddy/Let's Encrypt
[x] scripts/deploy.sh                   one-shot server setup (Docker, git, keys, firewall)
[x] scripts/backup.sh                   Postgres dump + LND SCB, 14-day retention, cron-ready
[x] scripts/init-lnd.sh                 automated wallet creation via REST API + auto-unlock config
[x] .env.example updated                production DB creds, signet macaroon paths, ocdn.is endpoint
[x] Server access                       SSH key auth, passwordless sudo, UFW (22/80/443/9735)
[x] Docker + stack deploy               all 6 containers healthy: caddy, gateway, mint1, coordinator, lnd, postgres
[x] LND signet wallet                   created via REST API, auto-unlock configured, neutrino synced
[x] HTTPS live                          https://ocdn.is/health ‚Üí OK, Let's Encrypt cert auto-provisioned
[x] Mint 1 operational                  co-located on founder VPS (Romania), signing receipts
[x] Coordinator operational             epoch scheduler running, Postgres persisting
[ ] LND signet funding                  fund via signet faucet, open channel to well-connected node
[ ] Mint 2 (remote)                     separate VPS in Malaysia (Shinjiru) or Switzerland (COIN.HOST)
[ ] Mint 3 (remote)                     third jurisdiction ‚Äî add before public announcement
[x] Caddyfile.production routes          added /event, /payreq, /events, /feed/*, /thread/*, /cid/* routes
[x] Seed content upload                 9 ANNOUNCE + 8 FUND + 3 POST + 1 LIST = 21 events live
    - manifesto.txt (1.7K, TEXT, open)   ‚Üí d020ba0f..477f  ‡∏ø1785
    - protocol-spec.json (1.9K, JSON)    ‚Üí b59fb39d..64d2  ‡∏ø851
    - architecture.html (3.3K, HTML)     ‚Üí 9bc46489..f1da  ‡∏ø426
    - economics.csv (767B, CSV)          ‚Üí 8ed92b82..5df2  ‡∏ø179
    - ocdn-logo.png (1K, IMAGE)          ‚Üí 38cf54a5..b25f  ‡∏ø86
    - epoch-simulation.csv (1.4M, 6 blocks) ‚Üí 6880624b..f0ee  ‡∏ø4251
    - collection: README.md + host-guide.txt + threat-model.txt ‚Üí LIST a25d6c7b..a940
    - 3 threaded comments on manifesto, architecture, epoch-sim
[x] Shareable URLs                      https://ocdn.is/asset/<root> returns content
    - round-trip verified: upload ‚Üí fetch ‚Üí diff = identical
    - multi-block chunking verified (6 blocks, 256 KiB each)
    - free preview works (blocks ‚â§16 KiB); L402 gate works (blocks >16 KiB)
[x] Monitoring                          GET /status endpoint (coordinator): LND balance, hosts, epochs, pools, uptime
    - scripts/monitor.sh: health checks, LND balance, disk alerts, cron-ready
    - Caddyfile.production: /status route exposed
    - @dupenet/lnd-client: getBalance() method (on-chain + channel + active channels)
[ ] Backup cron                         schedule scripts/backup.sh every 6h
[x] Multi-endpoint client config        CLI endpoints[] array, retry-with-rotation (all commands)
    - CliConfig: gateways[], coordinators[] with backward-compatible gateway/coordinator fields
    - http.ts: fetchWithRotation() ‚Äî network error ‚Üí rotate to next endpoint
    - httpGetRotate, httpGetBytesRotate, httpPostRotate helpers
    - All CLI commands updated: fetch, fund, post, tip, info, hosts, pin, upload
    - DUPENET_GATEWAYS/DUPENET_COORDINATORS env vars (comma-separated)
[x] Hardcoded bootstrap list            founder endpoints (ocdn.is) built into CLI config.ts
[ ] .onion address                      Tor hidden service in compose-production.yml
[ ] Second domain                       separate registrar/TLD pointing to same or different IP
[ ] peers.json rolling cache            ~/.dupenet/peers.json updated on every successful interaction
[ ] Daily Bitcoin anchoring (L7)        1 tx/day, Taproot tweak, epoch_summary + snapshot hash
    - infrastructure side; UI verify page + crisis readiness in Sprint 7e

Exit: public URL serves real content via L402. External client can `dupenet fetch` from anywhere.
      Client survives founder endpoint outage via retry-with-rotation + cache + .onion fallback.
      Daily Bitcoin anchor makes all protocol state verifiable. Crisis spike degrades gracefully.

## Sprint 9 ‚Äî Multi-host (prove the network)

Second host connects to the founder's coordinator and mirrors content.
DocRef: MVP_PLAN:¬ßNode Kit (Target: Raspberry Pi), ¬ßBounty Pool Mechanics

[ ] Second VPS (or Pi)                  deploy compose-nodekit.yml pointing at founder coordinator
[ ] Node-agent mirrors content          agent discovers bounty feed, mirrors top CIDs from founder gateway
[ ] Directory shows 2 hosts             GET /directory lists both with pricing + availability
[ ] Spot-checks pass                    coordinator verifies second host has blocks (GET /spot-check)
[x] Failover works                      CLI retry-with-rotation across all known gateways (network errors trigger rotation)
[x] CLI host selection                  `dupenet fetch` queries /directory, sorts by cheapest, merges with config gateways
[ ] Receipt flow from second host       L402 fetch from host 2 ‚Üí receipt ‚Üí epoch settlement includes both hosts

Exit: two independent hosts serve the same CID. Kill one, content survives. Receipts flow from both.


================================================================================
PATH A.1: EventV1 + REFERENCE MATERIALIZER (no VPS dependency ‚Äî build while waiting)
================================================================================

Goal: collapse all non-blob, non-receipt protocol actions into EventV1 envelope.
Build reference materializer that interprets kind bytes. Content becomes discoverable,
fundable, and discussable via one endpoint (POST /event) and one query (GET /events).
DocRef: MVP_PLAN:¬ßProtocol vs Materializer Boundary, ¬ßEvent Layer, ¬ßEvent Kind Payload Conventions

Architectural decision (2025-02-08):
  - Protocol surface area is the enemy. Proof-of-service is sacred. Everything else is views.
  - EventV1 { v, kind, from, ref, body, sats, ts, sig } is the only non-blob protocol primitive.
  - Protocol rule: if event.sats > 0, credit pool[event.ref] += sats. That's it.
  - Kind interpretation, threading, ranking, author rewards, pin lifecycle, moderation = materializer.
  - Tip / upvote / fortify / pin are all the same action: POST /event with sats > 0.
  - Pins are kind=PIN_POLICY events with drain policy in body. Materializer enforces SLA.
  - Author earnings: not in protocol. Authors self-host (earn as hosts), earn via revenue share
    (revshare_bps on ANNOUNCE ‚Äî materializer-enforced, third-party payments only), or materializer bonuses.
  - Existing POST /tip, POST /host/register, POST /content/announce ‚Üí collapse into POST /event.
  - ReceiptV2 + epoch settlement untouched. Don't fix what's not broken.

## Sprint 7b ‚Äî EventV1 Envelope (packages/physics)

The protocol-level event primitive. Everything in materializer depends on this.
ALSO: fixes all divergences marked "Sprint 7b" in ¬ßDIVERGENCES above.

[x] EventV1 TypeBox schema             { v: u8, kind: u8, from: bytes32, ref: bytes32, body: bytes, sats: u64, ts: u64, sig }
    - canonical serialization (same pattern as existing schemas)
    - event_id = SHA256(canonical(EventV1 minus sig))
    - Ed25519 signature: sign/verify canonical(EventV1 minus sig)
    - body: hex-encoded CBOR, inline ‚â§16 KiB (kind-specific payload)
    - sats: economic weight (0 = free statement, >0 = pool credit)
    - packages/physics/src/schemas/event.ts + packages/physics/src/event-v1.ts
[x] Kind byte constants                0x01 FUND, 0x02 ANNOUNCE, 0x03 POST, 0x04 HOST, 0x05 REFUSAL,
                                       0x06 ATTEST, 0x07 LIST, 0x08 PIN_POLICY, 0x09 MATERIALIZER
    - packages/physics/src/constants.ts: EVENT_KIND_* constants
[x] Kind payload schemas (TypeBox)     AnnouncePayload, HostPayload, ListPayload, PinPayload
    - these are materializer conventions, not protocol ‚Äî live under physics for convenience
    - unknown kinds: preserve, don't reject (extensibility)
    - AnnouncePayload.access: "open" | "paid" (default "paid") ‚Äî publisher intent for open-access serving
      "open" = full content served without L402 (hosts earn from bounty pool only)
      materializer renders inline vs behind paywall based on this field
      see MVP_PLAN:¬ßNew User Journey (First Contact), ¬ßOpen Access Tier
[x] PricingV1.open_min_pool_sats       DONE (added in prior sprint) ‚Äî already in TypeBox schema + constants
    - pool below threshold ‚Üí host declines open-access, falls back to L402
    - prevents free-CDN abuse: open access is sponsored availability, not charity
    - default: 500 sats (OPEN_MIN_POOL_SATS_DEFAULT in constants)
[x] Pool credit rule                   if event.sats > 0: credit pool[event.ref] += sats (minus royalty)
    - pool_key = event.ref (bytes32 ‚Äî can be CID, event_id, topic hash)
    - protocol is key-blind; materializer resolves ref ‚Üí CID for settlement
    - implemented in POST /event handler (apps/coordinator/src/server.ts)
[x] EventV1 tests                      24 tests: construct, sign, verify, event_id, body encode/decode, kind constants
    - packages/physics/test/vectors/event-v1.test.ts
[x] Migrate existing events            POST /event accepts all kinds; POST /tip + POST /host/register remain as shims
    - backward compat: existing POST /tip, POST /host/register still work
    - new canonical path: POST /event (accepts any kind)
    - kind=HOST events trigger host registration as materializer side effect

Divergence fixes (bundled into this sprint ‚Äî see ¬ßDIVERGENCES):
[x] Replace fee model                  DONE ‚Äî royalty.ts + bounty-pool.ts + constants.ts. 170/170 tests pass.
[x] PricingV1 complete                 DONE ‚Äî 4 new Optional fields in TypeBox schema. Constants added.
[x] New constants                      DONE ‚Äî EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES, EVENT_POW_TARGET.
[x] Pool key ‚Üí bytes32                 Prisma BountyPool.cid ‚Üí poolKey (@map("cid") preserves column).
    - bounty-pool.ts, epoch-settlement.ts, server.ts, all tests updated
    - pool key accepts any bytes32: CID, event_id, topic hash
[x] GET /cid/:hash endpoint            gateway: if asset ‚Üí 302 /asset/; if file ‚Üí 302 /file/; if block ‚Üí serve bytes.
    - apps/gateway/src/routes/cid.ts: nano-blob path for events ‚â§ CHUNK_SIZE
[x] Free preview tier                  blocks ‚â§ FREE_PREVIEW_MAX_BYTES (16 KiB) served without L402.
    - apps/gateway/src/routes/block.ts: check before L402 gate
    - configurable: FREE_PREVIEW_ENABLED env var (default true)
    - L402 tests disable preview to exercise paid flow
[ ] BASE_FEE                           21-210 sats (dynamic, EIP-1559 style) ‚Äî EventV1 ingest pricing.
[x] Node-agent publishes min_bounty_sats  in PricingV1 during host registration.
    - apps/node-agent/src/config.ts: AGENT_MIN_BOUNTY_SATS, AGENT_OPEN_MIN_POOL_SATS
    - apps/node-agent/src/announce.ts: includes min_bounty_sats + open_min_pool_sats in pricing

Exit: physics exports EventV1. Construct event, sign, verify. Pool rule tested.
      Kind payloads constructable/verifiable. One envelope replaces per-action schemas.
      Fee model is volume-tapering royalty, not flat 5%. Pool keys accept any bytes32.
      Gateway serves nano-blobs via GET /cid/:hash. Free preview tier works.
      PricingV1 has all 6 fields.

## Sprint 7c ‚Äî Batch Upload + Content Metadata (apps/cli)

The whistleblower flow: upload a directory of PDFs with human-readable metadata.
All publishing now goes through POST /event with appropriate kind bytes.

[x] `dupenet upload <dir>`              batch upload: chunk + upload each file in directory
    - recursive traversal (sorted, skips hidden files), filters by known MIME extensions
    - progress: [N/M] filename, blocks: X/Y (Z%), cached count
    - skip already-uploaded blocks (409 Conflict = ok, resume on failure)
    - per-file ANNOUNCE event (title = relative path, inherits --tags/--access)
    - after all uploads: POST kind=LIST event for collection (items = all asset_roots)
    - error handling: failed files logged, remaining files continue
    - summary: uploaded X/Y files (size, blocks)
[x] Upload metadata + ANNOUNCE          `dupenet upload` now emits ANNOUNCE event after asset upload
    - --title, --tags, --access open|paid flags
    - ANNOUNCE body: title, mime, size, access, tags (CBOR-encoded)
    - graceful fallback: if no keys or coordinator down, upload still succeeds
[ ] Thumbnail generation                generate preview thumbnails client-side (images: 200px JPEG; text: 500 char excerpt)
[x] `dupenet fund <ref> <sats>`         POST /event kind=FUND ‚Üí pool credit
    - works for any ref: CID, event_id, topic hash
    - prints event_id, pool_credit, royalty
[x] `dupenet post <ref> <text>`         POST /event kind=POST ‚Üí threaded reply
    - ref = parent event_id (reply) or topic hash (root post)
    - body = CBOR-encoded { text } ‚â§16 KiB
    - optional --sats flag to boost own post

Exit: `dupenet upload ~/leak/ --title "Court Filings" --tags epstein,legal`
      ‚Üí uploads 200 PDFs, publishes ANNOUNCE + LIST events, prints collection URL.
      `dupenet fund <list_event_id> 10000` ‚Üí credits pool. One endpoint.
      `dupenet post <event_id> "This proves X"` ‚Üí threaded reply published.

## Sprint 7d ‚Äî Signal Aggregation + Market Quoting (apps/coordinator ‚Äî reference materializer)

Materializer views over EventV1 stream. These are product features, not protocol.
All endpoints are materializer conventions ‚Äî other materializers may offer different views.

[x] POST /event                         DONE in Sprint 7b ‚Äî validates EventV1, credits pool, stores in event log
    - now also stores in indexed ProtocolEvent table (Sprint 7d)
    - rate-limit per pubkey/IP deferred (sufficient at founder scale)
[x] GET /events?ref=&kind=&from=&since= generic event query ‚Äî all filters optional, AND-combined, newest first
    - apps/coordinator/src/views/materializer.ts: queryEvents()
[x] Prisma model: ProtocolEvent         { id, eventId, kind, from, ref, body, sats, ts, sig }
    - indexes: (ref), (kind, ts), (from, ts), (event_id unique)
    - separate from generic Event log ‚Äî this is the queryable materializer view
[x] GET /feed/recent                    recent ANNOUNCE events (paginated, filterable by tags)
    - decodes CBOR body ‚Üí title, description, tags, mime, size, access
[x] GET /feed/funded                    pool_keys ranked by balance + ANNOUNCE metadata enrichment
    - host_count per pool key, most recent ANNOUNCE decoded for metadata
[x] GET /host/:pubkey/scorecard         host reputation (from HOST events + spot-checks + receipts)
[x] GET /content/:ref/signals           content resilience + graph importance (dual score)
[x] GET /author/:pubkey/profile         pseudonymous reputation (events by pubkey + demand on their content)
[x] GET /market/quote                   supply curve from host min_bounty_sats thresholds
    - also: preserve tier pricing (Gold/Silver/Bronze sats estimates)
    - also: auto-bid contribution estimate per CID
    - consumed by PreserveButton for tier selector UX
[x] GET /thread/:event_id               thread tree: recursive ref-chain resolution from POST events
    - depth-limited (default 10), builds in-memory tree, sorted oldest-first
[ ] GET /cluster/:ref?hops=N            graph neighborhood: all nodes within N hops via ref/body/list edges
[x] Body edge extraction                parse [ref:bytes32] tokens from POST/ANNOUNCE bodies at ingest
    - Prisma model: BodyEdge { source_event_id, target_ref, edge_sats }
    - index: (target_ref) for inbound citation queries
[x] Graph importance computation        weighted PageRank over citation DAG (ref + body + list edges)
    - incremental: recompute affected neighborhoods on new events
    - expose via GET /content/:ref/signals (graph_importance field)
[ ] Event-to-blob promotion             funded events above threshold serialized as CIDs ‚Üí PUT /block
    - materializer policy: threshold configurable (e.g. 1000 sats)
    - promoted events enter normal replication market
[x] GET /orphans                        three-part orphan score: high direct pool + low graph connectivity
                                       (few inbound ref/body edges from funded events) + low discussion depth
                                       (few/zero kind=POST replies). "Funded, but under-analyzed." Analyst job board.
                                       Hard to game: inflating pool costs real sats, reducing connectivity means
                                       not linking to the node (defeats visibility gaming).

Exit: POST /event accepts all kinds. GET /events returns filtered stream.
      GET /feed/funded ranks by dual score (direct pool + graph importance).
      GET /cluster/<ref> returns citation neighborhood. GET /orphans surfaces undiscussed funded content.
      GET /thread/<id> returns discussion tree. Signal endpoints are materializer views ‚Äî not protocol.

## Sprint 7d.1 ‚Äî Event Log Compaction + Snapshot Bootstrap (packages/physics + apps/coordinator)

Unchanged in scope. Snapshots now cover pools (keyed by ref) instead of bounty pools (keyed by CID).
DocRef: MVP_PLAN:¬ßEvent Log Growth + Compaction, ¬ßLongevity L7

[ ] StateSnapshotV1 schema             physics: epoch, merkle roots for pools / hosts / events / serves, event_count, prev_hash
[ ] Merkle tree library                physics: build from sorted key-value pairs, generate/verify inclusion proofs
[ ] Snapshot generator                 coordinator: materialize Prisma state into StateSnapshotV1
[ ] GET /snapshot/latest, GET /snapshot/:epoch, GET /snapshot/:epoch/proof/:key
[ ] Receipt rollup in epoch settlement EpochSummary stores receipt merkle_root + counts only
[ ] GET /bootstrap                     fast node sync: latest snapshot + events since
[ ] Snapshot verification              publisher sig (MVP), Bitcoin-anchored epoch root (L7)
[ ] Snapshot + inclusion proof tests

Exit: GET /bootstrap returns snapshot + recent events. New node materializes in seconds.

## Sprint 7e ‚Äî The Leaderboard + Web Surface (the product)

The global importance scoreboard ‚Äî content ranked by economic commitment. The product that
drives adoption, distribution, funding, and institutional revenue. The new user journey
(MVP_PLAN:¬ßNew User Journey) lives or dies here.
DocRef: MVP_PLAN:¬ßThe Leaderboard (Step 8), ¬ßNew User Journey (First Contact)

### Minimum ship (4 pages + interaction) ‚Äî DONE

[x] Scaffold web app                   apps/web, Next.js 15, App Router, server + client components
    - monospace system font, no CSS framework, minimal client JS (~3 kB per interactive page)
    - API client: src/lib/api.ts (server-side), src/lib/event-client.ts (client-side)
    - revalidate=30s server-side caching, router.refresh() after user actions

[x] / Leaderboard
    - network stats header: item count, ‡∏ø total sats, üíø active hosts
    - table: rank #, ‡∏ø sats, üíø hosts, title (linked), üîç proof link
    - IdentityChip in header (float right)
    - symbols as column headers (‡∏ø üíø üîç), no text labels
    - (deferred: SSE live updates, velocity indicators, inline +‡∏ø per row)

[x] /v/<ref> Content page
    - title, author ¬∑ date, description, [tags]
    - instrument cluster: ‡∏ø sats  ìÄ† funders  üíø copies  ‚ó∑ ~Nmo  ‚óè paid/‚óã open
    - +‡∏ø fortify ¬∑ ‚§ì download ¬∑ üîç proof
    - activity pulse: +‡∏ø210 ab12 3m ¬∑ üí¨ cd34 1h (recent fund/post events)
    - üí¨ N thread count + nested replies (from ¬∑ sats ¬∑ Nago)
    - üí¨ comment box
    - GET /content/:ref/stats ‚Äî one-call aggregated stats for cluster
    - (deferred: inline render for open-access, SSE counter, collection back-link)

[x] /c/<list> Collection page
    - title, item count, author, date, description
    - table: ‡∏ø balance per item, ref link, üîç proof link
    - pool balance fetched per item via GET /bounty/:ref
    - (deferred: Fund All flow, collection item sizes)

[x] /p/<ref> Proof page
    - hash + "sha256"
    - instrument cluster: ‡∏ø sats  ìÄ† funders  üíø copies  ‚Üª last payout epoch
    - üíø N trusted hosts table: endpoint, pk, score
    - ‚úì N epoch proofs table: epoch, host, rcpt, clt, ‡∏ø reward
    - [x] copy hash + copy url buttons (CopyButton component)
    - [x] ‚§ìjson evidence bundle download (GET /api/evidence/:ref)
    - (deferred: Bitcoin anchor txid, verify now re-check)

### Screen interaction polish (6-screen model)

1) Read (/v/<ref>)
[x] Collection back-link               if ref appears in LIST event, show ‚óÄ link to /c/<list>

2) Fortify (+‡∏ø)
[x] Amount buttons 210/21k/21m         replace [21,210,2100] with [210,21000,21000000], labels: 210/21k/21m
[x] Fortify modal/sheet                extract from inline to overlay/bottom-sheet for mobile
    - payment pending: spinner (‡∏ø...) + auto-poll 3s, no manual "I paid" button

3) Discuss (üí¨)
[x] Event PoW (Web Worker)             cross-ref: see ¬ßClient interaction model below

4) Explore (/ leaderboard)
[x] Inline +‡∏ø on rows                  FortifyButton per leaderboard row (or link to /v/<ref>#+‡∏ø)

5) Fund collection (/c/<list>)
[ ] Fund All flow                      amount input ‚Üí size-weighted split across items ‚Üí N FUND events ‚Üí payment UI
[ ] Collection item sizes              fetch ANNOUNCE metadata for size field per item

6) Verify (/p/<ref>)
[x] Copy proof URL                     copy hash + /p/<ref> URL to clipboard (CopyButton component)
[x] Export evidence bundle             GET /api/evidence/:ref ‚Üí downloadable JSON
    - packages: ref hash, sha256 verification note, pool (balance, funded, funders, last payout),
      hosts (count, trusted list with endpoint/pubkey/score), epoch proofs (last 6)
    - Content-Disposition: attachment; filename="evidence-<ref12>.json"
    - ‚§ìjson link on proof page after hash/url copy buttons
[ ] Verify now                         re-check hash + spot-check endpoints on demand

### Next pass (add after 6-screen loop proves out)

[ ] Topic leaderboards: /topic/<tag>   tag filter on leaderboard, not separate page
[ ] Cluster page: /g/<ref>             graph neighborhood (needs enough edges to be useful)
[ ] Thread page: /t/<event_id>         separate thread view (threads already render on /v/<ref>)
[ ] Thread bundle page: /b/<bundle_cid> archived conversation snapshot
[ ] Orphan filter                      "sort by: needs analysis" on leaderboard (not separate page)
[ ] Host scorecard: /h/<pubkey>        operator-facing, add when there are operators
[x] Embeddable widget                  self-contained HTML iframe, no JS dependencies
    - GET /api/widget ‚Üí mini leaderboard (top N, configurable ?n=5)
    - GET /api/widget/:ref ‚Üí content card (title, ‡∏ø balance, ìÄ† funders, üíø copies, ‚ó∑ runway, +‡∏ø link)
    - inline CSS, 30s cache, all links open main site in _blank
    - embed code: <iframe src="/api/widget/:ref" width="320" height="100">
    - "embed" copy button on proof page (/p/<ref>)
    - (deferred: inline bootstrap snippet, multi-host resolution, self-updating widget CID)
[ ] Velocity indicators, collection sort/filter, inbound/outbound citation counts
[ ] Fund Thread button                 fan-out over ref-chain (cheap to add, but comment+Fortify first)
[ ] Market quote tooltip               "+‡∏ø X ‚Üí est. +Y replicas" on Fortify button

### Client interaction model (MVP_PLAN:¬ßClient Interaction Model)

[x] Browser keypair lifecycle           generate Ed25519 on first write ‚Üí indexedDB + localStorage (pk)
    - src/lib/keys.ts: indexedDB "dupenet" store, localStorage cache for pubkey hex
    - src/components/KeyProvider.tsx: React context, IdentityChip (short pubkey + generate/clear)
    - "no key" mode: read-only browsing, write prompts key creation (1 tap)
    - uses @noble/ed25519 + @noble/hashes (cross-browser, incl. Firefox)
    - (deferred: NIP-07 upgrade, export/import)
[x] Event construction in browser       browser-native crypto, no physics dependency in client bundle
    - src/lib/crypto.ts: minimal deterministic CBOR encoder (RFC 8949 canonical, matches cbor-x)
    - Ed25519 sign via @noble/ed25519, SHA256 via @noble/hashes/sha2
    - EventV1 compose ‚Üí sign ‚Üí POST /api/event proxy ‚Üí coordinator
    - src/lib/event-client.ts: createFundEvent, createPostEvent, postEvent
[x] Fortify button                     amount selector (21/210/2100/custom) ‚Üí sign FUND event ‚Üí POST
    - src/components/FortifyButton.tsx: "use client", amount picker, status feedback
    - on /v/<ref> content page: [fortify] link ‚Üí amount selector ‚Üí send ‚Üí "funded" ‚Üí refresh
    - full payment flow: payreq ‚Üí WebLN auto-pay ‚Üí invoice fallback ‚Üí sign + POST
[x] Comment box                         text input ‚Üí sign POST event (kind=0x03) ‚Üí POST
    - src/components/CommentBox.tsx: "use client", textarea, status feedback
    - ref = root event_id (ANNOUNCE or content ref), thread appears after refresh
[x] API proxy routes                    POST /api/event, POST /api/payreq, GET /api/payreq/:hash
    - keeps coordinator URL server-side, no CORS needed
[x] Page integration                    IdentityChip on leaderboard, FortifyButton + CommentBox on /v/<ref>
    - layout.tsx: KeyProvider wraps all pages
    - page.tsx: IdentityChip in header (float right)
    - v/[ref]/page.tsx: FortifyButton + CommentBox below content
[x] Payment-intent binding              POST /payreq { sats, event_hash } ‚Üí LN invoice bound to event
    - coordinator: POST /payreq creates invoice via LndClient, stores in PaymentStore (10-min TTL)
    - coordinator: GET /payreq/:payment_hash polls LND for settlement status
    - coordinator: POST /event verifies payment (lookupInvoice) before crediting pool
    - dev mode (no LND): sats trusted without payment ‚Äî sufficient at founder scale
    - web: FortifyButton handles 3 tiers:
      1. WebLN auto-pay (window.webln.sendPayment) ‚Üí instant
      2. Invoice string + lightning: URI link ‚Üí manual pay ‚Üí poll for settlement
      3. Dev mode bypass (no invoice, direct sign + POST)
    - src/lib/webln.ts: WebLN type declarations, hasWebLN(), payWithWebLN()
    - apps/coordinator/src/views/payment-store.ts: in-memory store (dual-keyed by event_hash + payment_hash)
[x] Event PoW (Web Worker)             free writes: PoW in Web Worker, never block UI
    - challenge = SHA256("EV1_POW" || from || ts_be64 || kind_u8 || ref || SHA256(body_bytes))
    - find nonce where H(challenge || nonce_be64) < EVENT_POW_TARGET (2^240, ~200ms mobile)
    - physics: buildEventPowChallenge(), verifyEventPow() in event-v1.ts
    - browser: pow-worker.ts (Web Worker, @noble/hashes SHA256), pow.ts (wrapper, fallback to main thread)
    - CommentBox: "üí¨mining..." ‚Üí "üí¨sending..." ‚Üí "üí¨‚úì" (PoW transparent to user)
    - coordinator: REQUIRE_EVENT_POW=true ‚Üí verifies pow_nonce + pow_hash on sats=0 events
    - event payload: pow_nonce (hex16) + pow_hash (hex64) travel alongside signed event (not signed)
[ ] Upload shim (MVP)                  POST /upload (multipart) ‚Üí materializer chunks ‚Üí returns asset_root
    - metadata events (ANNOUNCE/LIST) always signed client-side
    - returns identical objects to client-side chunking (drop-in swap later)
[ ] SSE endpoints                      GET /sse/global (leaderboard), GET /sse/ref/<ref> (per-content)
    - message types: fund_delta, new_event, replica_change, rank_shift
    - optimistic UI insert on submit, reconcile on SSE echo
[ ] Pending event queue                indexedDB: signed events stored offline, replay on reconnection, dedup by event_id
    - connects to ¬ßLongevity L2 (client-side event buffer)

### Fortify payment flow (MVP_PLAN:¬ßNew User Journey ‚Äî zero-to-sats)

[x] +‡∏ø UI + payment flow               amount selector + payreq + WebLN/invoice + sign + POST
[x] WebLN auto-pay (tier 1)            +‡∏ø ‚Üí WebLN.sendPayment() ‚Üí sign event ‚Üí POST ‚Üí 4-pack cycle
[x] Invoice/URI fallback (tier 2)      no WebLN ‚Üí lightning: URI link + copy button ‚Üí poll for settlement
[x] QR code display                    render QR from bolt11 (qrcode npm library + QRCode.tsx component)
[x] Wallet guide (tier 3)              no wallet ‚Üí one-screen guide (Phoenix/Alby). Accept bounce-and-return.
[ ] Fortify abandonment tracking        measure clicks ‚Üí completions per tier. Fiat bridge trigger: >60% abandon.

### Bitcoin integrity anchor (L7 ‚Äî pulled into MVP)

[ ] Daily Bitcoin tx                   Taproot tweak: SHA256(epoch_summary_merkle_root || state_snapshot_hash)
    - batched: 1 tx/day covering 6 epochs. ~$0.50/day.
[ ] Verify page: /verify/<ref>         paste CID or event_id ‚Üí inclusion proof path ‚Üí Bitcoin tx link
    - "integrity radiator" ‚Äî institutions won't touch without it

### Crisis readiness (before first spike)

[ ] Read-only mode                     one switch: disable writes, keep serving reads
[ ] Hot-path cache                     top 100 leaderboard items cached, invalidated on new events
[ ] Rate limiting                      materializer API per-IP (L402 surge pricing at volume)
[ ] Status page                        public uptime/health endpoint + incident comms template
[ ] Graceful degradation               widget and API serve cached data if coordinator overloaded

Exit: 4 pages ship. / shows leaderboard with live SSE updates. /v/<ref> shows content (open-access
      inline, paid behind L402), 3 stats, Fortify (WebLN+QR), comment box. /c/<list> shows collection
      with Fund All. /p/<ref> shows proof with Bitcoin anchor + evidence download.
      New user journey core loop works: arrive ‚Üí read ‚Üí fund ‚Üí comment ‚Üí prove.


================================================================================
PATH B: S3 ADAPTER (platform adoption)
================================================================================

Goal: existing apps switch to dupenet storage with a config change.
DocRef: MVP_PLAN:¬ßS3-Compatible Adapter (Layer A ‚Äî Migration Unlock)

## Sprint 10 ‚Äî S3-compatible adapter (apps/s3-adapter)

Thin shim that speaks S3 protocol and translates to the blob layer.
Single-tenant: runs alongside the consuming app, talks to one gateway.

[ ] Project scaffold                    apps/s3-adapter, TypeScript + Fastify (or http)
[ ] Auth layer                          S3 access key ‚Üí protocol pubkey mapping (thin translation)
    - single-user mode for MVP (one access key)
    - SigV4 signature verification (just enough to satisfy AWS SDKs)
[ ] PUT object ‚Üí chunk + upload         receive S3 PutObject ‚Üí chunk file ‚Üí PUT /block √ó N ‚Üí PUT /file ‚Üí PUT /asset
    - compute asset_root, return as ETag
    - handle multipart uploads (S3 multipart ‚Üí map to block uploads)
    - chunking reuses @dupenet/physics
[ ] GET object ‚Üí resolve + stream       S3 GetObject ‚Üí GET /asset ‚Üí GET /file ‚Üí stream GET /block √ó N
    - reassemble blocks into response stream
    - Range header support (partial reads)
    - Content-Type from AssetRoot mime
[ ] HEAD object                         S3 HeadObject ‚Üí HEAD /asset ‚Üí return size, content-type, ETag
[ ] DELETE object                       return 204 (no-op; content-addressed = no true delete)
[ ] LIST objects                        return list of known asset_roots (local cache)
    - or: return empty (many apps don't need LIST)
[ ] Bucket abstraction                  all objects in one "bucket" (single gateway = single bucket)
[ ] Integration test                    `aws s3 cp` in, `aws s3 cp` out, `aws s3 ls` ‚Üí identical bytes
[ ] Docker image                        add to compose-founder.yml as optional service

Exit: `aws s3 cp file.tar s3://dupenet/file.tar` succeeds.
      `aws s3 cp s3://dupenet/file.tar -` returns identical bytes.
      No code changes in the consuming app.

## Sprint 11 ‚Äî SDK + documentation

Make Layer A consumable by external developers.
DocRef: MVP_PLAN:¬ßReceipt Verification SDK, ¬ßAdoption Path

[ ] receipt-sdk published               npm publish @dupenet/receipt-sdk (zero deps, works everywhere)
[ ] physics published                   npm publish @dupenet/physics (or subset: canonical, cid, chunker)
[ ] HTTP API reference                  OpenAPI/Swagger spec for gateway + coordinator endpoints
    - generated from route definitions or hand-written
    - hosted at docs.dupenet.dev
[ ] Integration guide                   "Store files on dupenet in 5 minutes"
    - code samples: upload, fetch, tip, pin
    - S3 adapter setup guide
[ ] Receipt verification guide          "Verify paid consumption in your app"
    - import receipt-sdk ‚Üí verify receipts ‚Üí rank content / gate access
    - cross-platform use cases (Nostr, forums, media apps)
[ ] Pin contract guide                  "Pay for durability"
    - create pin, monitor copies, cancel/refund flow

Exit: a developer who has never seen the codebase can integrate in <1 hour.


================================================================================
REMAINING POLISH (non-blocking, do when convenient)
================================================================================

[ ] EXIF/metadata stripping             strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation           TypeBox schemas defined but Value.Check not called on ingest
[ ] Stake locking via LND               verify stake payment on host registration (currently stubbed)
[ ] Deterministic Docker builds         Nix flake or pinned multi-stage (DocRef: MVP_PLAN:¬ßLongevity L6)
[ ] Epoch root anchoring                Bitcoin tx per epoch: SHA256(epoch_summary_root || snapshot_hash) (DocRef: MVP_PLAN:¬ßLongevity L7)
    - makes state snapshots trustlessly verifiable (no need to trust coordinator)
    - depends on Sprint 7d.1 (snapshot format must exist first)
    - Taproot tweak or OP_RETURN, ~$0.50/day at 1 tx/day covering 6 epochs

External review fixes (solved ‚Äî applied to mvp_plan.md):
[x] FileManifest merkle_root            real binary Merkle tree (leaf hash + pair hash), not SHA256(concat) (#1)
    - enables inclusion proofs, streaming verification, partial block validation
[x] Stake language: custodial            "deposited with coordinator ‚Äî custodial in MVP" (#4)
    - post-MVP: on-chain UTXO, federation, or DLC-based escrow
[x] Free preview rate limiting           per-IP token bucket (60 burst / 10 sustained); CDN for founder hosts (#6)
    - hosts can disable free tier; MUST rate-limit if enabled
[x] Storage pricing knob                 sats_per_gb_month: u64? added to PricingV1 TypeBox schema (host.ts)
    - enables durability estimation: (bounty - egress_drain) / (storage_cost * size_gb) = months
[x] Pin SLA semantics                    best effort + full refund if min_copies unmet 6 epochs (#10)
    - no PIN_CANCEL_FEE on SLA-triggered cancel; regions relaxable via signed amendment


================================================================================
POST-MVP ASSESSMENT (deferred from external review, assess after launch)
================================================================================

DocRef: MVP_PLAN:¬ßPost-MVP Assessment Queue

[ ] Event spam pricing                 decide: paid ingest (402-gated POST /event) vs rate-limited + PoW
    - MVP: materializer rate-limits per pubkey/IP (sufficient at founder scale)
    - POST kind=POST (threaded comments) especially needs friction: PoW min, optional sats
    - assess once real event volume + abuse patterns visible
    - paid ingest funds materializers (product toll, not protocol toll)
    - PoW per event acceptable for humans; evaluate impact on automated publishers

[ ] min_bounty_sats quote gaming       compute behavioral thresholds from HostServe event data
    - MVP: founder knows all hosts, gaming irrelevant
    - post-MVP: observed_threshold = min bounty at which host first served a CID
    - show confidence intervals (self-reported vs observed) when data sufficient
    - separately evaluate slashable signed quotes (expands slash surface beyond crypto fraud)
    - trigger: host count > 50 and supply curve UI is live

[ ] Multi-source parallel download     client fetches blocks from multiple hosts simultaneously
    - MVP: single-host fetch with failover (sufficient for 2-3 hosts)
    - protocol already supports it (block-level addressing + multiple hosts per CID)
    - deferred: partial-file payment economics, block availability bitmap, stripe strategy
    - trigger: 3+ hosts serve the same CID in production

[ ] Receipt privacy (ephemeral pubkeys) clients SHOULD use one-time keypairs for receipt submission (#5)
    - receipt submission already opt-in; casual readers (L402 only) have no protocol exposure
    - ephemeral pubkeys don't weaken anti-sybil: hard defense is economic (L402 cost + mint token),
      not identity-based (key generation is free; PoW escalation per-pubkey already trivially bypassed)
    - RECEIPT_MIN_UNIQUE removed; client diversity is now a smooth log2 bonus multiplier
      on payout_weight, not a binary threshold (see mvp_plan.md ¬ßEpoch Structure)
    - lean on payment-based diversity signals: distinct payment_hash, temporal spread, graph breadth
    - aggregator remains MVP privacy trust point (same as all founder dependencies)
    - long-term: blinded/bearer receipts (Cashu-style) for zero-knowledge demand proofs
    - spec updated: MVP_PLAN:¬ßReceipt Privacy (DocRef: MVP_PLAN:¬ßFetch Flow, ¬ßHost Self-Farming)

[ ] Audit griefing hardening            cap frequency, deterministic target selection (#9)
    - cap audit frequency per (host, cid, epoch) ‚Äî prevents bandwidth griefing
    - PRF-based audit target selection (auditable but unpredictable to host)
    - L402 cost already gates spam audits; separate auditor bond adds complexity, defer
    - regional selective failure (honest to auditor IPs, corrupt to others): operational fix (Tor), not protocol fix
    - trigger: audit volume becomes meaningful (>100 audits/day)

[ ] Client safety layer                 layered pre/post-fetch safety, no sandboxing (#11)
    - mirrors operator attestation model (¬ßOperator Content Policy) applied to client side
    - pre-fetch: MIME-type gate (warn on executables/scripts), publisher signal display, CID denylist
    - post-fetch: SHA256 verify (already in spec), magic bytes vs declared MIME, known-good list check
    - ClientPolicyV1 schema: attester_follow, mime_warn, mime_block, trusted_publishers, threshold
      same import/export format as operator policy JSON
    - known-good lists = signed kind=LIST events from projects (code signing via CIDs)
    - encrypted blobs opaque to attesters ‚Äî packs only work for known-flagged unencrypted CIDs
    - out of scope: OS-level sandboxing, content rating, server-side scanning, global blocklist
    - applied to mvp_plan.md: new ¬ßClient Safety Layer section
    - trigger: first malware incident in production

[~] Materializer market + paid ingest   materializers = metadata hosts, same L402 economics (#12 + A)
    - key insight: materializer is a host for metadata ‚Äî ingest events (POST /event),
      serve queries (GET /events, GET /feed, GET /thread). Same L402, same market.
    - EventV1 envelope + kind bytes formalized (2025-02-08 architectural decision)
    - kind=MATERIALIZER event for discovery; MaterializerPayload in kind conventions
    - MVP: founder is sole materializer; free ingest (rate-limited), free queries
    - author rewards = materializer product feature (rebate/bonus from materializer fees), NOT protocol
    - remaining design work (post-MVP, trigger: second materializer operator):
      - relay-vs-materializer economic separation at scale
      - consistency model for divergent materializer state
      - economic tuning: ingest fee vs query fee balance

[ ] Founder service replacement specs   inputs/outputs/swap procedure per service (B)
    - for each: directory, mints, aggregator, snapshots, provisioning, materializer
    - test: can a stranger replace it without "contact the founder"?
    - if not, the longevity section should say so honestly
    - trigger: pre-launch documentation pass


================================================================================
MVP PLAN UPDATE: DUAL-MODE HOST ECONOMICS + STOREFRONT (2026-02-10)
================================================================================

Architectural reframe applied to mvp_plan.md:

[x] Dual-mode host economics             replaced "open vs paid" binary with spectrum
    - `access` field is publisher *signal*, not host *constraint*
    - Two earning streams always both available: bounty (epoch rewards) + vending (L402 egress)
    - Hosts earn from BOTH simultaneously on every CID they serve
    - Open-access fetches generate receipts identical to paid fetches ‚Äî settlement doesn't distinguish
    - Host self-upload (vending-first): upload ‚Üí set pricing ‚Üí earn from L402 sales. Bounty composes if others Fortify.
    - Fixed error: old plan said "no egress revenue on open-access fetches" ‚Äî now correctly states both streams active

[x] Storefront rendering model            web app = storefront, not directory
    - /v/<ref> renders content inline, not behind download link
    - Open content: full render, fetched server-side from gateway. "Free to read, pay to preserve."
    - Paid content: free preview (‚â§16 KiB), price tag + Buy button (cheapest host from directory)
    - Always show: instrument cluster, Fortify button, discussion thread, proof link
    - Download link becomes secondary ("raw" link for power users)
    - Prerequisite: gateway must persist asset/file manifests to disk (in-memory Map bug)

[x] Demand signal from receipts           receipt_count as traffic proxy
    - GET /feed/funded enriched with demand field (fetches/epoch)
    - Open-access receipts count ‚Üí demand reflects real readership
    - Instrument cluster shows demand alongside funding, copies, runway
    - Node-agents use demand + balance for smarter mirror targeting

[x] Directory pricing display             per-host per-CID pricing in UI
    - "Served by 3 hosts ¬∑ from ‚Çø3/fetch" (paid) or "Open access ¬∑ funded for ~8mo" (open)
    - Buy button resolves cheapest host from GET /directory
    - Per-host pricing visible on proof page

What this does NOT change:
    - Protocol (receipts, settlement, pool credits ‚Äî all identical)
    - EventV1 envelope (ANNOUNCE `access` field already exists)
    - PricingV1 (already has all needed fields)
    - Host registration / spot-checks / scoring
    - Epoch settlement logic (receipts are receipts regardless of access mode)

Sections updated in mvp_plan.md:
    - ¬ßEgress Pricing ‚Üí ¬ßDual-Mode Host Economics (rewritten)
    - ¬ßEvent Kind Bytes table (ANNOUNCE row updated)
    - ¬ßLayer 3: Earnings (dual streams noted)
    - ¬ßInterface Boundaries (operator earns from both streams)
    - ¬ßEpoch-Based Rewards (receipts not qualified as "paid")
    - ¬ßStep 8 (retitled to "Leaderboard + Storefront", content page spec rewritten)
    - ¬ßNew User Journey (arrival section, economics, decision tree, Step 8 deliverables)
    - ¬ßFlywheel A (host self-upload vending-first noted)
    - ¬ßGET /feed/funded (demand field added)
    - ¬ßGET /content/:ref/signals (demand field added)


================================================================================
MVP PLAN UPDATE: ECONOMICS REWORK + STRATEGIC ADDITIONS (2026-02-10)
================================================================================

Changes applied to mvp_plan.md from CEO/strategic review. Cross-referenced
against codebase to identify all rework needed.

## Protocol Rework ‚Äî Egress Royalty (new mechanic)

mvp_plan.md now specifies EGRESS_ROYALTY_PCT = 0.01 (flat 1% of L402 egress fees,
deducted at epoch settlement, credited to FOUNDER_PUBKEY). Code has no egress
royalty path.

[x] EGRESS_ROYALTY_PCT constant          packages/physics/src/constants.ts ‚Äî 0.01
[x] Egress royalty function              packages/physics/src/royalty.ts ‚Äî computeEgressRoyalty(egress_sats)
    - flat 1%, no taper (distinct from pool credit royalty)
    - deducted from proven egress at settlement (receipt_token binds price_sats)
[x] Settlement egress deduction          apps/coordinator/src/views/epoch-settlement.ts
    - settleEpoch() sums proven egress per host per CID per epoch
    - deducts 1% before crediting host share
    - credits FOUNDER_PUBKEY with deducted amount
[x] Egress royalty tests                 packages/physics/test/vectors/royalty.test.ts ‚Äî 9 egress tests
    - flat 1% at all volumes, correct deduction, host receives 99%
[x] Coordinator settlement tests         apps/coordinator/test/epoch-settlement.test.ts
    - verify egress royalty deducted alongside aggregator fee + pool credit royalty

## Protocol Rework ‚Äî Smooth Payout Multiplier (replaces 5/3 hard gate)

mvp_plan.md now replaces hard 5/3 threshold with smooth payout_weight formula.
Code currently enforces receipt_count >= 5 AND unique_clients >= 3 as binary gate.

Files to change:
    packages/physics/src/constants.ts
    packages/physics/src/epoch-aggregation.ts (isPayoutEligible)
    packages/physics/src/reward.ts (computeHostScore, distributeRewards)

[x] Constants update                     packages/physics/src/constants.ts
    - RECEIPT_MIN_COUNT: 5 ‚Üí 1
    - RECEIPT_MIN_UNIQUE_CLIENTS: removed
    - W_CLIENTS: removed (absorbed into payout_weight)
    - W_UPTIME: 0.3 ‚Üí 0.6
    - W_DIVERSITY: 0.2 ‚Üí 0.4
[x] isPayoutEligible() rewrite           packages/physics/src/epoch-aggregation.ts
    - new: receipt_count >= 1 AND total_proven_sats > 0
[x] payout_weight() function             packages/physics/src/epoch-aggregation.ts ‚Äî computePayoutWeight()
    - payout_weight = total_proven_sats * (1 + log2(unique_clients))
    - totalProvenSats field on EpochGroup (sum of price_sats across receipts)
[x] computeHostScore() rewrite           packages/physics/src/reward.ts
    - new: payout_weight * (W_UPTIME * uptimeRatio + W_DIVERSITY * diversityContribution)
    - HostScore type has payoutWeight field
[x] Epoch aggregation tests              packages/physics/test/vectors/epoch-aggregation.test.ts
    - hosts with 1 receipt / 1 client now eligible (small payout_weight)
    - hosts with 5 receipts / 5 clients get ~3.3x multiplier vs 1/1
    - smooth: no cliff at 5/3 boundary
[x] Score computation tests              packages/physics/test/vectors/reward.test.ts
    - expected scores match multiplicative formula
    - verify smooth scaling: no discontinuities, no cliffs
[x] Coordinator settlement tests         apps/coordinator/test/epoch-settlement.test.ts
    - updated formula flows through end-to-end

## Schema Update ‚Äî AnnouncePayload Author Fields

mvp_plan.md now includes author_pubkey? + revshare_bps? on ANNOUNCE payload.
Code has no author fields in AnnouncePayload.

[ ] AnnouncePayload schema update        packages/physics/src/schemas/event.ts
    - add: author_pubkey: Type.Optional(Type.String({ minLength: 64, maxLength: 64 }))
    - add: revshare_bps: Type.Optional(Type.Integer({ minimum: 0, maximum: 10000 }))
    - backward-compatible (Optional fields, additionalProperties: false ‚Üí true or keep false + add)
[ ] CLI --author-pubkey, --revshare      apps/cli/src/commands/upload.ts
    - optional flags on `dupenet upload`
    - populate author_pubkey + revshare_bps in ANNOUNCE body
[ ] Author split enforcement             apps/coordinator/src/views/epoch-settlement.ts
    - at settlement: if ANNOUNCE for CID has revshare_bps, split host payout
    - only third-party payments qualify (exclude events where from == author_pubkey)
    - deferred until materializer has enough data to verify third-party constraint
[~] Author split ‚Äî mark as design-ready  schema in place, enforcement deferred to post-MVP or when
    first author requests it. Don't block launch.

## Materializer Endpoints ‚Äî New

[x] GET /host/roi                        apps/coordinator/src/views/graph.ts
    - top earning CIDs last 24h (from EpochSummaryRecords)
    - estimated sats/day if mirror top 20 CIDs (from bounty feed + drain rates)
    - median payout time (from settlement timestamps)
    - host conversion surface: "how much will I earn?"
[x] GET /market/quote                    apps/coordinator/src/views/graph.ts (moved from materializer.ts)
    - supply curve from host min_bounty_sats thresholds
    - outcome quotes: "N replicas for ~M days at X sats"
    - preserve tier pricing: Gold/Silver/Bronze sats estimates
    - auto-bid contribution estimate per CID
    - consumed by PreserveButton for tier selector UX

## Materializer Endpoints ‚Äî Graph (prerequisite for triangle labels)

[x] Body edge extraction at ingest       apps/coordinator/src/views/graph.ts
    - parse [ref:bytes32] tokens from POST/ANNOUNCE bodies on POST /event
    - Prisma model: BodyEdge { source_event_id, target_ref, edge_sats }
    - index: (target_ref) for inbound citation queries
    - BLOCKS: triangle labels, graph importance, orphan score, cluster view
[x] Graph importance computation         apps/coordinator/src/views/graph.ts
    - weighted PageRank over citation DAG (ref + body + list edges)
    - incremental recompute on new events
[ ] Importance triangle labels           apps/coordinator/src/views/graph.ts (data layer ready, UI pending)
    - compute percentile ranks: pool (Commitment), receipts/epoch (Demand), PageRank (Centrality)
    - assign labels: Underpriced (high centrality + low pool), Flash (high demand + low pool),
      Endowed (high pool + low demand + low centrality)
    - expose via GET /content/:ref/signals or GET /feed/funded enrichment

## Web App ‚Äî UI Changes

[ ] FortifyButton ‚Üí PreserveButton      apps/web/src/components/FortifyButton.tsx
    - phase 1: tier labels alongside amounts (Gold/Silver/Bronze presets, Custom fallback)
    - phase 2: real PRESERVE events when escrow + clearing ships (Step 7c)
    - depends on GET /market/quote endpoint (tier pricing)
    - see ¬ßCLEARINGHOUSE MODEL: Web App ‚Äî Preserve Tiers for full spec
[ ] Widget deployment validation         apps/web ‚Äî verify widget is deployment-ready
    - widget is [x] built (GET /api/widget, GET /api/widget/:ref)
    - validate: works as standalone iframe embed on external page
    - validate: cached/degraded mode when coordinator unreachable
    - GTM artifact ‚Äî must be ready before Week 2 media outreach
[ ] Funders-per-asset tracking           apps/coordinator + apps/web
    - funder_count already computed from distinct `from` pubkeys on FUND events ‚úì
    - add: expose as obsession metric in leaderboard header or /api/stats
    - add: track trend (funders-per-asset this week vs last week)

## Pre-Existing Blockers (now more critical)

[x] Gateway manifest persistence         apps/gateway/src/storage/metadata-store.ts
    - ALREADY FIXED ‚Äî persists to _meta/manifests/ and _meta/assets/ on disk
    - loads on startup, survives restarts
    - progress_overview lines 20-22 still say "in-memory Map" ‚Äî stale text ‚úì

## Seed Content ‚Äî Graph Seeding (content task, not code)

Depends on body edge extraction being implemented first.

[ ] Seed 200+ body edges                 via `dupenet post` with [ref:bytes32] citations
    - 20 hub docs with 5-10 inbound edges each
    - 3-5 controversy clusters (docs contradicting each other, linked by analysis)
    - edges can be short: "[ref:X] contradicts [ref:Y]"
[ ] Verify triangle labels render        after graph importance + body edges live
    - at least one item should show Underpriced, Flash, or Endowed label


================================================================================
STALE REFERENCES (text in this file that now contradicts mvp_plan.md)
================================================================================

Audit date: 2026-02-10. Items below are text-only fixes in this file.

[x] Line 109-111: epoch aggregation      FIXED ‚Äî now says smooth payout_weight, no 5/3 reference
[x] Line 116: settlement deductions      FIXED ‚Äî settlement now shows aggregator fee (3%),
    egress royalty (1%), and auto-bids (2% of proven egress ‚Üí pool) inline
[x] Line 20-22: "in-memory Map"          FIXED ‚Äî now says "persisted to disk via MetadataStore"
[ ] Line 422: author earnings            old: "Authors self-host or earn via materializer bonuses"
    - update to include author revenue share convention (revshare_bps on ANNOUNCE)


================================================================================
MVP PLAN UPDATE: CLEARINGHOUSE MODEL + AUTO-BIDS + PRESERVE ORDERS (2026-02-10)
================================================================================

Architectural reframe applied to mvp_plan.md from CEO/strategic review.
Core insight: founder is clearinghouse operator (exchange model), not just toll collector.
Three new mechanisms: auto-bids from traffic, preserve orders, epoch-boundary clearing.
All materializer-level ‚Äî zero protocol changes to pools, receipts, or settlement.

Sections updated in mvp_plan.md:
    - ¬ßCore Thesis ‚Äî added #9 (availability has a clearing price)
    - ¬ßValue Capture table ‚Äî added clearing spread + auto-bid rows
    - ¬ßFee Model Layer 4 ‚Äî clearing spread as line item
    - ¬ßBounty Pool Mechanics ¬ßAccumulation ‚Äî three entry paths (auto-bids, preserve orders, raw FUND)
    - ¬ßPreserve Orders ‚Äî new section (PreserveOrderV1, aggregation, clearing, lifecycle)
    - ¬ßSustainability Ratio ‚Äî new subsection
    - ¬ßDual-Mode Host Economics ‚Äî auto-bid paragraph
    - ¬ßSignal Layer content signals ‚Äî 3 new rows (organic income, sustainability ratio, preserve backers)
    - ¬ßEvent Kind table ‚Äî PIN_POLICY notes evolution, kind=PRESERVE (0x0A) added
    - ¬ßStep 8 UX ‚Äî "Preserve" tiers replace raw Fortify as primary CTA
    - ¬ßProtocol Enforcement ‚Äî preserve-eligible bonded host tier
    - ¬ßImplementation Order ‚Äî Step 7c added (preservation clearing)
    - ¬ßConstants ‚Äî 7 new constants + 3 derived values

What this does NOT change:
    - Protocol (pools, receipts, settlement, epoch structure ‚Äî all identical)
    - EventV1 envelope (new kind byte 0x0A is additive)
    - Existing FUND events (still work, still irrevocable, power-user path)
    - Existing Pin contracts (preserve extends pins, don't replace them)
    - Host lifecycle (base tier unchanged; preserve-eligible is opt-in addition)

## Physics ‚Äî New Constants + Schemas

[x] AUTO_BID_PCT constant                 packages/physics/src/constants.ts ‚Äî 0.02 (2%)
    - % of L402 egress price auto-credited to pool[fetched_cid] per receipt
    - subject to pool credit royalty (founder earns on auto-bids)
[x] CLEARING_SPREAD_PCT constant          packages/physics/src/constants.ts ‚Äî 0.03 (3%)
    - % of matched preserve value taken by clearinghouse
    - does not taper (product toll, not protocol toll)
[x] Preserve constants                       packages/physics/src/constants.ts
    - PRESERVE_ESCROW_TIMEOUT_EPOCHS = 6 (24h)
    - PRESERVE_CANCEL_FEE_PCT = 0.02 (2%)
    - PRESERVE_GOLD_REPLICAS = 10
    - PRESERVE_SILVER_REPLICAS = 5
    - PRESERVE_BRONZE_REPLICAS = 3
[x] EVENT_KIND_PRESERVE constant             packages/physics/src/constants.ts ‚Äî 0x0A
[ ] PreservePayload TypeBox schema           packages/physics/src/schemas/event.ts
    - tier: "GOLD" | "SILVER" | "BRONZE" | "CUSTOM"
    - target_replicas: u8, min_jurisdictions: u8, duration_epochs: u32
    - max_price_per_epoch: u64, auto_renew: bool
    - materializer convention (same pattern as AnnouncePayload, HostPayload, etc.)
[ ] PreserveOrderV1 TypeBox schema    packages/physics/src/schemas/preserve.ts (or inline in event.ts)
    - full preserve object: cid, tier, params, funder, sig
    - preserve_id = SHA256(canonical(PreserveOrderV1))
[x] computeAutoBid() function             packages/physics/src/auto-bid.ts
    - computeAutoBid(price_sats: number): number ‚Äî returns floor(price_sats * AUTO_BID_PCT)
    - computeEpochAutoBids(receipts[]): AutoBidResult[] ‚Äî groups by CID, per-CID aggregation
      reduces rounding loss vs per-receipt computation
[x] sustainabilityRatio() function        packages/physics/src/auto-bid.ts
    - sustainabilityRatio(organic_income, preservation_cost): number
    - isSelfSustaining(organic_income, preservation_cost): boolean ‚Äî ratio >= 1.0
[ ] computeClearingPrice() function       packages/physics/src/clearing.ts
    - inputs: aggregate demand (target_replicas, max_price_per_epoch), host supply count
    - output: clearing_price_per_epoch, matched_replicas
    - pure function, no side effects ‚Äî coordinator calls at epoch boundary
[ ] aggregatePreserves() function            packages/physics/src/clearing.ts
    - inputs: active preserve orders for a CID
    - output: aggregate demand profile (total target, median willingness, backer count)
[x] Auto-bid tests                        packages/physics/test/vectors/auto-bid.test.ts (28 tests)
    - computeAutoBid at various price points, zero price, rounding
    - computeEpochAutoBids with multiple CIDs, multi-host grouping, zero-price skip
    - per-CID aggregation reduces rounding loss vs per-receipt
    - sustainabilityRatio edge cases (zero income, zero cost, exact 1.0)
    - isSelfSustaining boundary cases
[ ] Clearing tests                        packages/physics/test/vectors/clearing.test.ts
    - clearing price with various demand/supply ratios
    - aggregatePreserves: single funder, multi-funder, mixed tiers
    - clearing spread deduction
[ ] Preserve schema tests                    packages/physics/test/vectors/preserve.test.ts
    - PreservePayload construct, encode, decode, canonical serialization
    - preserve_id deterministic (same params ‚Üí same ID)
    - tier presets produce correct target_replicas / min_jurisdictions / duration

## Coordinator ‚Äî Auto-Bid Generation (ships with Step 8)

Auto-bids are a settlement-time computation. No new endpoints needed.
Minimal code: epoch settlement sums L402 receipts, computes auto-bids, credits pools.

[x] Auto-bid in settleEpoch()             apps/coordinator/src/views/epoch-settlement.ts
    - after receipt aggregation: computeEpochAutoBids(digests) per CID
    - credit pool[cid] via creditTip() (applies founder royalty to auto-bids)
    - tracks totalAutoBidSats + totalAutoBidRoyaltySats in SettlementResult
    - EpochSummaryRecord stores per-CID autoBidSats + egressRoyaltySats
    - event log includes total_auto_bid_sats + total_auto_bid_royalty_sats
[x] EpochSummaryRecord schema update      apps/coordinator/prisma/schema.prisma
    - add: autoBidSats Int @default(0)
    - add: egressRoyaltySats Int @default(0)
    - backward-compatible (defaults)
[x] Auto-bid settlement tests             apps/coordinator/test/epoch-settlement.test.ts (7 new tests)
    - verify auto-bid credits pool at 2% of proven egress (with royalty)
    - multiple CIDs ‚Üí separate auto-bid credits
    - zero-price receipts ‚Üí no auto-bids
    - small egress rounding to 0 ‚Üí no auto-bid
    - creates pool if CID has no existing pool
    - EpochSummaryRecord includes autoBidSats field
    - event log includes auto-bid totals

## Coordinator ‚Äî Preserve Escrow + Clearing (Step 7c ‚Äî post-launch iteration)

Preserve orders require a new Prisma model and clearing logic. Ships after launch.
Phased: tier UX + aggregation display first (Step 8), escrow + clearing second (7c).

[ ] Prisma model: PreserveEscrow             apps/coordinator/prisma/schema.prisma
    - id, preserveId (unique), poolKey, funder, tier, targetReplicas, minJurisdictions
    - durationEpochs, maxPricePerEpoch, autoRenew, escrowed_sats
    - status: ACTIVE | LAPSED | CANCELLED
    - created_epoch, expiry_epoch
    - indexes: (poolKey), (funder), (status, expiry_epoch)
[ ] POST /event kind=PRESERVE handling       apps/coordinator/src/server.ts
    - validate PreservePayload body
    - compute escrow amount: tier-based estimate from market/quote or max_price * duration
    - require payment (same payreq flow as FUND events)
    - store in PreserveEscrow (sats held, NOT credited to pool yet)
    - pool credit happens at clearing, not at preserve creation
[ ] Epoch-boundary clearing               apps/coordinator/src/views/clearing.ts
    - runs after settleEpoch() each epoch boundary
    - per CID with active preserves:
      1. aggregatePreserves() ‚Üí aggregate demand profile
      2. count serving hosts (from HostServe records)
      3. computeClearingPrice() ‚Üí clearing price
      4. matched_value = clearing_price * min(aggregate_target, actual_hosts)
      5. deduct CLEARING_SPREAD_PCT from matched_value ‚Üí founder income
      6. credit pool[cid] += (matched_value - spread)
      7. deduct from each preserve order's escrowed_sats proportionally
    - integrate into createEpochScheduler() tick cycle
[ ] Preserve lifecycle management            apps/coordinator/src/views/clearing.ts
    - LAPSED: preserve.expiry_epoch reached ‚Üí status=LAPSED, remaining escrow stays
      (auto_renew=true ‚Üí extend, deduct new escrow; false ‚Üí refund remaining)
    - CANCELLED: POST /preserve/:id/cancel ‚Üí refund unused escrow minus PRESERVE_CANCEL_FEE_PCT
    - ESCROW_TIMEOUT: unmatched preserve after PRESERVE_ESCROW_TIMEOUT_EPOCHS ‚Üí auto-refund
[ ] POST /preserve/:id/cancel endpoint       apps/coordinator/src/server.ts
    - validate sig from funder
    - compute refund: remaining_escrow * (1 - PRESERVE_CANCEL_FEE_PCT)
    - status ‚Üí CANCELLED
[ ] GET /preserve/:id endpoint               apps/coordinator/src/server.ts
    - returns preserve status, escrow remaining, epochs remaining, matched_this_epoch
[ ] Bid aggregation view                  apps/coordinator/src/views/clearing.ts
    - per-CID demand profile: total backers, aggregate target replicas,
      median willingness-to-pay, tier breakdown (N Gold, M Silver, K Bronze)
    - cached, refreshed each epoch
[ ] GET /market/orderbook/<cid>           apps/coordinator/src/server.ts
    - demand side: aggregate preserve bids (backers, tiers, total committed)
    - supply side: serving hosts count + committed hosts (preserve-eligible)
    - clearing price estimate (if clearing ran now)
    - extends existing GET /market/quote
[ ] GET /content/:ref/sustainability      apps/coordinator/src/server.ts
    - organic_auto_bid_income: avg auto-bid sats/epoch (from recent EpochSummaryRecords)
    - preservation_cost: clearing_price * current_replicas (or estimated from drain rate)
    - sustainability_ratio: income / cost
    - self_sustaining: boolean (ratio >= 1.0)
    - label: "Self-sustaining" | "Needs N more sats/epoch" | "Unfunded"
[ ] Clearing tests                        apps/coordinator/test/clearing.test.ts
    - single preserve ‚Üí pool credit at clearing price
    - multi-funder aggregation ‚Üí correct aggregate demand
    - clearing spread deducted ‚Üí founder income
    - preserve expiry ‚Üí LAPSED + refund (auto_renew=false) or extend (true)
    - preserve cancel ‚Üí refund minus fee
    - escrow timeout ‚Üí auto-refund
    - no active preserves ‚Üí clearing is no-op
    - clearing + auto-bids compose correctly (both credit pool in same epoch)
[ ] Sustainability tests                  apps/coordinator/test/clearing.test.ts
    - ratio >= 1.0 ‚Üí self-sustaining
    - ratio < 1.0 ‚Üí shows deficit
    - zero traffic ‚Üí zero organic income
    - no preserves, only auto-bids ‚Üí still computes sustainability

## Coordinator ‚Äî Committed Hosts + OFFER Events (post-launch, materializer-level)

Hosts opt into preserve fulfillment via kind=OFFER events with additional bond.
Clearinghouse guarantees preserve outcomes; host bonds are the insurance pool
for re-matching. Protocol's "never slash for availability" preserved ‚Äî
this is product-layer commitment, not protocol.

[x] EVENT_KIND_OFFER constant              packages/physics/src/constants.ts ‚Äî 0x0B
[ ] OfferPayload TypeBox schema            packages/physics/src/schemas/event.ts
    - replicas: u8, regions: string[], price_per_epoch: u64, bond_sats: u64, duration_epochs: u32
    - materializer convention (supply-side counterpart to PreservePayload)
[ ] Prisma model: HostOfferCommitment     apps/coordinator/prisma/schema.prisma
    - hostPubkey, poolKey, bondSats, replicas, regions, pricePerEpoch
    - committed_epochs, start_epoch
    - status: COMMITTED | FULFILLED | FORFEITED
[ ] POST /event kind=OFFER handling       apps/coordinator/src/server.ts
    - validate OfferPayload, verify bond payment, store commitment
    - supply-side orderbook: clearinghouse matches OFFERs against PRESERVEs
[ ] Clearinghouse guarantee enforcement   apps/coordinator/src/views/clearing.ts
    - clearinghouse guarantees preserve outcomes to funders
    - funder's SLA is with clearinghouse, not individual hosts
    - if committed host fails spot-checks ‚Üí clearinghouse re-matches from bond pool within 1 epoch
    - funder never sees which host failed ‚Äî just "Gold tier maintained"
    - if clearinghouse fails ‚Üí degrades to best-effort spot market (same as FUND)
[ ] Bond forfeiture on availability failure
    - if committed host fails spot-checks during active preserve ‚Üí forfeit bond
    - bond compensates clearinghouse re-matching cost
    - distinct from protocol slashing (this is materializer enforcement)
[ ] Host commitment in clearing           clearing.ts ‚Äî prefer OFFER-bonded hosts when matching
    - committed hosts earn clearing price (premium)
    - commodity hosts earn residual pool drain (baseline)
[ ] GET /host/:pubkey/commitments         return active OFFER commitments for host
[ ] Host commitment + OFFER tests

## Web App ‚Äî Preserve Tiers + Sustainability Display

[ ] FortifyButton ‚Üí PreserveButton       apps/web/src/components/FortifyButton.tsx (rename or extend)
    - default CTA: tier selector (Gold / Silver / Bronze / Custom)
    - Gold: "10 replicas, 3+ jurisdictions, ~6mo" ‚Üí price from market/quote
    - Silver: "5 replicas, 2+ jurisdictions, ~3mo" ‚Üí price from market/quote
    - Bronze: "3 replicas, ~1mo" ‚Üí price from market/quote
    - Custom: freeform sats input (raw FUND event, existing behavior)
    - Gold/Silver/Bronze ‚Üí sign PRESERVE event ‚Üí payreq ‚Üí payment ‚Üí POST /event kind=PRESERVE
    - Custom ‚Üí existing FUND event flow (unchanged)
    - depends on: GET /market/quote (for tier pricing), PreservePayload schema
    - phasing: ship tier labels + estimated pricing with Step 8 (using FUND events internally)
             upgrade to real PRESERVE events when escrow + clearing lands (Step 7c)
[ ] Sustainability ratio in instrument    apps/web/src/app/v/[ref]/page.tsx
    - fetch GET /content/:ref/sustainability
    - display: "Self-sustaining ‚úì" (green) | "Needs N sats/epoch" (amber) | "Unfunded" (red)
    - when self-sustaining: Preserve button text ‚Üí "Already self-sustaining. Boost to Gold?"
    - phasing: show estimated sustainability from drain_rate first (no auto-bid data until
             settlement runs with auto-bid code), upgrade when auto-bid data flows
[ ] Auto-bid income display               apps/web/src/app/v/[ref]/page.tsx
    - "Generates N sats/epoch from organic traffic"
    - alongside existing instrument cluster (‡∏ø sats, ìÄ† funders, üíø copies, ‚ó∑ runway)
    - data from GET /content/:ref/sustainability endpoint
[ ] Preserve backer display                  apps/web/src/app/v/[ref]/page.tsx
    - "N backers ¬∑ Gold tier ¬∑ funded through <month>"
    - from aggregated preserve data (GET /market/orderbook/:cid or /content/:ref/sustainability)
    - phasing: show funder count (existing) first, add preserve tier info when preserve ships
[ ] Leaderboard sustainability column     apps/web/src/app/page.tsx
    - add column or indicator: self-sustaining badge per item
    - sort option: "sort by: needs funding" (low sustainability ratio first)

## Sprint 7d ‚Äî Update Existing Tasks

These existing Sprint 7d tasks now also serve the clearinghouse model:

    GET /market/quote already planned (line 542, 1059-1062) ‚Äî NOW ALSO:
    [ ] Quote preserve tier pricing            compute sats required per tier (Gold/Silver/Bronze)
        from supply curve + drain rate + host count. Consumed by PreserveButton.
    [ ] Quote auto-bid contribution         show: "this CID generates ~N sats/epoch from traffic"
        even before formal sustainability endpoint exists.

    GET /content/:ref/signals already planned (line 540, 296) ‚Äî NOW ALSO:
    [ ] Include sustainability fields       organic_auto_bid_income, preservation_cost,
        sustainability_ratio, self_sustaining, active_preserve_backers, aggregate_preserve_tier

    GET /feed/funded already done (line 537-538) ‚Äî FUTURE UPDATE:
    [ ] Enrich with sustainability          add sustainability_ratio per item when auto-bid
        data becomes available. Sort option: "needs funding."

## CLI ‚Äî Preserve Commands

[ ] `dupenet preserve <ref> <tier>`          apps/cli/src/commands/preserve.ts
    - POST /event kind=PRESERVE with tier preset (gold/silver/bronze)
    - --duration, --replicas, --jurisdictions for custom
    - --auto-renew flag
    - payreq ‚Üí payment ‚Üí POST /event
    - prints: preserve_id, escrow amount, tier, duration, estimated cost
[ ] `dupenet preserve status <preserve_id>`     GET /preserve/:id ‚Üí print status, escrow remaining, epochs left
[ ] `dupenet preserve cancel <preserve_id>`     POST /preserve/:id/cancel ‚Üí print refund amount

## Implementation Phasing

Phase A (ships with Step 8 ‚Äî settlement-time, no new infrastructure):
    [x] AUTO_BID_PCT + CLEARING_SPREAD_PCT + preserve tier constants in physics
    [x] computeAutoBid() + computeEpochAutoBids() in physics
    [x] Auto-bid generation in settleEpoch() (credits pools with royalty)
    [x] sustainabilityRatio() + isSelfSustaining() in physics
    [x] EpochSummaryRecord: autoBidSats + egressRoyaltySats fields
    [x] EVENT_KIND_PRESERVE + EVENT_KIND_OFFER constants
    [ ] Tier labels in FortifyButton (Gold/Silver/Bronze ‚Üí mapped to FUND events initially)
    [ ] Sustainability estimate in instrument cluster (from drain_rate, before real auto-bid data)

Phase B (Step 7c iteration ‚Äî after launch, when bid volume justifies):
    - PreserveOrderV1 schema + PreservePayload
    - PreserveEscrow Prisma model + escrow logic
    - Epoch-boundary clearing
    - Preserve lifecycle (create, cancel, lapse, auto-renew)
    - GET /market/orderbook, GET /content/:ref/sustainability
    - PreserveButton sends real PRESERVE events (replaces FUND shim)
    - CLI preserve commands

Phase C (post-launch, when host count > 10):
    - Host OFFER events (kind=0x0B) + bond
    - Clearinghouse guarantee enforcement (re-matching from bond pool)
    - Premium (bonded OFFER) vs commodity (spot) host tiers in clearing
    - Full orderbook display in UI (preserve demand + OFFER supply)


================================================================================
SPRINT A IMPLEMENTATION (2026-02-10)
================================================================================

[x] QR code for Lightning payments      apps/web: qrcode npm dep + QRCode.tsx component
    - LightningQR: renders BOLT11 invoice as scannable QR (data-URL PNG, tap-to-pay link)
[x] Fortify modal/sheet for mobile      FortifyButton.tsx rewritten as bottom-sheet modal
    - mobile: slides up from bottom; desktop: centered dialog
    - payment pending: spinner + auto-poll 3s, no manual button
    - QR code rendered in paying state
[x] Tier labels in FortifyButton        Gold (‡∏ø21m) / Silver (‡∏ø21k) / Bronze (‡∏ø210)
    - estimated replicas + runway per tier
    - custom amount input below presets
    - internally still FUND events (real PRESERVE in Sprint F)
[x] Inline +‡∏ø on leaderboard rows       FortifyButton inline mode ‚Üí links to /v/ref#fortify
[x] Sustainability estimate              instrument cluster: "funded ~Nmo" (from drain_rate)
[x] Widget deployment validation         stale-while-revalidate=300 cache headers on both widgets
    - widgets handle coordinator-unreachable gracefully (empty data / default values)
    - embed copy button already on proof page
[x] Wallet guide                         /wallet-guide page: Phoenix, Alby, Zeus recommendations
    - linked from Fortify modal "no wallet?" hint
    Total: 293/293 tests pass + Next.js build clean + coordinator tsc clean


================================================================================
SPRINT C IMPLEMENTATION (2026-02-10)
================================================================================

[x] BodyEdge Prisma model               body_edge table: source_event_id, source_ref, target_ref, edge_sats, source_kind
    - indexes: (target_ref), (source_event_id), (source_ref)
[x] GraphImportance Prisma model         graph_importance table: ref (PK), score, inbound_edges, outbound_edges, updated_epoch
[x] Body edge extraction at ingest       apps/coordinator/src/views/graph.ts: extractBodyEdges()
    - parses [ref:hex64] tokens from hex-encoded CBOR bodies
    - extracts LIST items as structural edges
    - integrated into POST /event handler (extractAndStoreEdges called after storeProtocolEvent)
    - edge sats split evenly across edges from source event
[x] Graph importance computation         computeGraphImportance(): weighted PageRank over citation DAG
    - damping=0.85, max 20 iterations, convergence threshold 0.0001
    - edges weighted by edgeSats (economic weight of citation)
    - incremental edge count updates on new events
[x] GET /content/:ref/signals            dual score: pool_balance √ó (1 + graph_importance √ó 1000)
    - returns: pool_balance, graph_importance, dual_score, inbound/outbound edges,
      host_count, funder_count, discussion_depth, runway_months, demand_receipts
[x] GET /market/quote                    supply curve from host min_bounty_sats thresholds
    - tier pricing estimates: Gold (10 replicas √ó 6mo), Silver (5 √ó 3mo), Bronze (3 √ó 1mo)
    - median price across trusted hosts
    - supply curve at 9 threshold points
[x] GET /host/:pubkey/scorecard          host reputation from protocol data
    - total_receipts, total_rewards, served_cids, spot_check_pass_rate,
      active_epochs, availability_score
[x] GET /author/:pubkey/profile          pseudonymous reputation
    - total_events, announcements, posts, funds, total_funded_sats,
      total_received_sats, unique_refs_funded, authored_refs, demand_receipts
[x] GET /orphans                         three-part orphan score
    - orphan_score = balance √ó (1/(1+connectivity)) √ó (1/(1+discussion_depth))
    - "funded but under-analyzed" ‚Äî analyst job board
    - enriched with ANNOUNCE metadata
[x] GET /host/roi                        host conversion surface
    - top_earning_cids (last 24h), estimated_sats_per_day, total_rewards_24h,
      median_payout_per_epoch
    Total: 293/293 tests pass + Next.js build clean + coordinator tsc clean (1 pre-existing TS6133)


LEGEND: [x] done  [~] partial/stub  [ ] not started
