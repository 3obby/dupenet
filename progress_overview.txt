dupenet MVP — Progress Overview
================================

PHASE 1: BLOB UTILITY (Layer A)
--------------------------------

## Step 1 — File Layer + Gateway + HTTP Origin

[x] Canonical serialization          deterministic CBOR, sorted keys (packages/physics)
[x] CID computation                  SHA256-based content addressing
[x] Chunker                          256KiB blocks, reassembly
[x] Merkle tree                      binary merkle, odd-leaf promotion
[x] FileManifestV1 schema            TypeBox schema (chunk_size, size, blocks[], merkle_root)
[x] AssetRootV1 schema               TypeBox schema (kind, original, variants, meta)
[x] PricingV1 schema                 min_request_sats, sats_per_gb, burst
[x] Block storage backend            filesystem: {base}/{h[0:2]}/{h[2:4]}/{hash}
[x] PUT /block/:cid                  SHA256 verified on receive, rejects mismatches
[x] GET /block/:cid                  serves bytes; L402-gated when LND configured, free in dev mode
[x] PUT /file/:root                  validates file_root = SHA256(canonical(manifest)), checks all blocks exist
[x] GET /file/:root                  returns manifest (in-memory Map)
[x] PUT /asset/:root                 validates asset_root = SHA256(canonical(AssetRoot)), checks file exists
[x] GET /asset/:root                 returns asset (in-memory Map)
[x] HEAD /asset/:root                returns size, kind, mime headers
[x] GET /pricing                     returns PricingV1
[x] GET /health                      gateway health check
[x] Physics unit tests               canonical, cid, chunker, merkle, reward, epoch-aggregation, availability, block-selection, event-signature (9 suites, vitest)
[x] Gateway integration test          PUT /block xN -> PUT /file -> PUT /asset -> GET -> reassemble -> verify (7 tests)
[ ] EXIF/metadata stripping           strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation         TypeBox schemas defined but Value.Check not called on ingest

## Step 2 — L402 Paid Fetch + Receipt Minting

[x] Mint service structure            POST /sign, GET /pubkey, GET /health (apps/mint)
[x] Ed25519 keypair load              loads from MINT_PRIVATE_KEY_HEX env var
[x] Receipt token format              Sign("R2" || host || epoch || block_cid || response_hash || price || payment_hash)
[x] LND service in docker compose     lnd v0.18.5-beta + bitcoind regtest, 2-node (alice+bob) in compose-founder.yml
[x] LND config fields                 LND_HOST, LND_MACAROON_PATH, LND_TLS_CERT_PATH in gateway + mint config
[x] LND client package                packages/lnd-client: LndClient interface, REST impl, MockLndClient for tests
[x] L402 challenge-response           GET /block returns 402 + invoice -> pay with preimage -> bytes + receipt_token
[x] Invoice store                     in-memory TTL map (payment_hash -> {cid, price, host, epoch, expiry})
[x] Invoice generation                gateway creates invoice via LndClient.createInvoice()
[x] Mint settlement check             mint calls LndClient.lookupInvoice(), verifies SETTLED + amount >= price
[x] Mint HTTP client                  gateway calls POST /sign on mint, receives receipt_token
[x] min_request_sats enforcement      price = min_request_sats used for all block fetches
[x] L402 integration tests            8 tests: 402 challenge, paid fetch, invalid/unknown/mismatch/single-use (mock LND)
[x] Client PoW receipt minting        minePoW(), buildChallengeRaw/ClientSigPayload/TokenPayload in physics
[x] Block selection (anti-special)    selectBlockIndex(), selectBlock(), verifyBlockSelection() in physics (SHA256 PRF)

## Step 3 — Node Kit + Host Registration

[x] compose-founder.yml               gateway, mint, coordinator, postgres, lnd, caddy (all with healthchecks)
[x] compose-nodekit.yml               gateway, node-agent, caddy
[x] Coordinator structure             Hono server with routes, event log, materialized views
[x] POST /host/register               registers host (stub stake verification)
[x] GET /directory                     returns host list from in-memory Map
[x] Node-agent poll loop                discover profitable CIDs → mirror from source → announce serve (complete)
[x] Mirror agent                       findProfitableTargets() queries GET /bounty/feed; mirrorCid() fetches + pushes
[x] Directory announcement             announceHost() signed registration; announceServe() signed HostServe
[x] Availability score tracking        computeAvailabilityScore() in physics + updateAllScores() in coordinator
[x] Status lifecycle                   PENDING->TRUSTED (score>=0.6), TRUSTED->DEGRADED (score<0.6), ->INACTIVE (score==0)
[x] Spot-check responder              GET /spot-check/:cid on gateway (verifies hash, no L402, no bytes)
[x] Spot-check runner                 spotCheckHost(), runAllChecks() in coordinator (injectable fetcher)
[x] SpotCheck Prisma model            hostPubkey, cid, epoch, passed, latencyMs, error
[x] POST /hosts/check                 triggers spot-checks for all active hosts, updates scores
[x] GET /hosts/:pubkey/checks         returns check history + availability score + recommended status
[x] Availability tests                9 physics + 12 coordinator tests (scoring, transitions, spot-check runner)
[ ] Stake locking via LND              TODO: verify stake payment
[x] CID selection agent                queries GET /bounty/feed, filters by minBounty, mirrors top profitability CIDs

## Step 4 — Receipt Verification SDK

[x] VerifyReceiptV2 function           packages/receipt-sdk, full verification logic
[x] Ed25519 verify                     Web Crypto API, zero dependencies
[x] PoW hash check                     H(challenge || nonce) < TARGET validation
[x] Client signature check             Ed25519 sig over receipt payload
[x] Zero external dependencies         only crypto.subtle
[x] Test vectors                       valid e2e receipt (construct -> verify), invalid hex/PoW/token, wrong mint key (7 tests)

## Step 5 — Pin Contracts

[x] PinContractV1 schema               TypeBox schema (physics) + Prisma model
[x] POST /pin                           creates pin, computes drain_rate, credits bounty pool, logs event
[x] GET /pin/:id                        returns status, remaining budget, active hosts, copies_met, epoch proofs
[x] POST /pin/:id/cancel               returns remaining budget minus 5% fee, status -> CANCELLED
[x] Drain rate enforcement              drainPinBudgets() deducts min(actualDrain, drainRate) per epoch
[x] Budget management                   creditBountyDirect (no protocol fee); debitPayout on cancel refund
[x] Lifecycle transitions               ACTIVE -> EXHAUSTED (when remainingBudget=0); ACTIVE -> CANCELLED (on cancel)
[x] min_copies check                    getPinStatus compares active hosts vs min_copies, returns copies_met
[x] Epoch proof bundle                  getPinStatus returns recent EpochSummaryRecords for pinned asset (last 6 epochs)
[x] Pin contract tests                  22 tests: validation, create, status, cancel, drain rate, exhaustion
[x] Pin ID deterministic                SHA256(canonical(pin content)) — duplicate detection via unique constraint

COORDINATOR — PERSISTENCE + AGGREGATION
-----------------------------------------

[x] Prisma schema                      Event, BountyPool, Host, HostServe, EpochSummaryRecord, PinContract
[x] Prisma client generated            in Dockerfile (npx prisma generate)
[x] POST /tip                          credits bounty pool (in-memory Map, stub sig verification)
[x] GET /bounty/:cid                   reads from in-memory Map
[x] Event log writer                   in-memory array (not persisted)
[x] Bounty pool view                   in-memory Map
[x] Host registry view                 in-memory Map
[x] Epoch math                         packages/physics: epoch length 4h, current epoch, epoch boundaries
[x] Reward formulas                    cidEpochCap, computeHostScore, distributeRewards (physics)
[x] EpochSummary schema                defined in physics
[x] Coordinator -> Postgres             bounty-pool, host-registry, event-log all use PrismaClient (tsc clean)
[x] Event log persistence               append-only Postgres via prisma.event.create
[x] POST /receipt/submit                validates via receipt-sdk, checks epoch range + replay, stores in Prisma
[x] Receipt validation pipeline         verifyReceiptV2 checks client_sig, PoW, receipt_token against mint pubkeys
[x] Epoch aggregation (physics)         aggregateReceipts(), isPayoutEligible() — pure receipt grouping + 5/3 threshold
[x] Epoch settlement (coordinator)      settleEpoch() — aggregate receipts, compute payouts, drain bounty, persist EpochSummary
[x] POST /epoch/settle                  validates epoch is closed, calls settleEpoch(), idempotent (no double-spend)
[x] GET /epoch/summary/:epoch           returns settlement results for a given epoch
[x] Payout execution                    distributeRewards() called by settleEpoch(), rewards split by host score
[x] Bounty drain                        cidEpochCap() limits per-epoch drain, debitPayout() debits pool
[x] Aggregator fee                      3% deducted from cap before host distribution
[x] Epoch settlement tests              8 coordinator tests (mock Prisma) + 12 physics aggregation tests
[x] Epoch boundary trigger              createEpochScheduler() auto-settles closed epochs; configurable interval + spot-checks
[x] Signature verification on events    Ed25519 verify on POST /tip and POST /host/register; rejects forged/missing sigs

DOCKER / DEPLOY
-----------------

[x] compose-founder.yml                bitcoind + lnd-alice + lnd-bob + gateway + mint + coordinator + postgres + caddy
[x] compose-nodekit.yml                gateway + node-agent + caddy (separate Caddyfile)
[x] Dockerfiles (4 apps)               multi-stage node:20-alpine builds (gateway, mint, coordinator, node-agent)
[x] Coordinator entrypoint             prisma db push --skip-generate on startup (idempotent)
[x] LND credential sharing             lnd-data volume mounted read-only to gateway + mint
[x] LND REST wiring                    gateway + mint create LndRestClient when macaroon exists (dev mode fallback)
[x] @noble/ed25519 sha512 setup        mint signer configures sha512Sync from @noble/hashes
[x] Caddyfile.founder                  gateway + coordinator routes (/spot-check, /epoch, /hosts added)
[x] Caddyfile.nodekit                  gateway-only routes
[x] scripts/gen-keys.sh                generates Ed25519 keypairs (host + 3 mints), writes .env.local
[x] scripts/fund-lnd.sh                funds alice + bob, opens 1M sat channel
[x] scripts/e2e.sh                     E2E test skeleton (needs polish for receipt/settle path)
[x] Startup config echo                all 4 apps print config on boot (port, LND mode, mint keys, genesis)
[x] GENESIS_TIMESTAMP_MS env var       coordinator + gateway; enables epoch boundary control for testing
[x] @types/node for Docker builds      physics + receipt-sdk; fixes Web Crypto type errors in Docker context
[x] Buffer.slice() fix (ed25519)       wcBuf() helper handles cbor-x Buffer views correctly

INTEGRATION / E2E
------------------

[x] Gateway round-trip test             upload multi-block file, retrieve by asset_root, verify SHA256 (7 tests)
[x] L402 flow test                      402 -> pay invoice -> receive block + receipt_token (8 tests, mock LND)
[x] Docker E2E                          FULL PASS: upload → 402 → bob pays → block + receipt_token → tip → receipt submit → epoch settle ✓
[x] Receipt round-trip test             construct valid receipt (PoW + mint sig + client sig) -> verifyReceiptV2 passes
[x] Epoch settlement test              mock Prisma: eligible/ineligible hosts, bounty drain, idempotency, score split
[x] Pin contract test                  mock Prisma: create/status/cancel, drain rate, exhaustion, validation (22 tests)
[x] Availability test                  mock Prisma + mock fetcher: spot-check, scoring, transitions (12 tests)
[x] Event signature test               real Ed25519 keypairs: signed tip/register accepted, forged/missing rejected (7 tests)
[x] Bounty feed + host/serve test     bounty feed returns profitable CIDs; signed serve announcements (6 tests)
[x] Node-agent poll cycle test        mock fetch: discover, mirror, error handling (6 tests)
[x] Epoch scheduler test             mock Prisma: tick settles, idempotent, start/stop, error handling (7 tests)

SPRINT ORDER (Phase 1 — complete)
-----------------------------------

1. Gateway integration tests            DONE (7 tests pass)
2. L402 + mint settlement               DONE (8 tests pass, mock LND; Docker E2E with real LND in sprint 6)
3. Coordinator -> Postgres              DONE (tsc clean; requires `prisma db push` + Postgres to run)
4a. Receipt submission + validation     DONE (receipt-sdk e2e test passes; coordinator handler typechecks)
4b. Epoch aggregation + payout          DONE (20 new tests: 12 physics + 8 coordinator; bounty drains correctly)
5. Pin contracts lifecycle              DONE (22 new tests; create, cancel, drain rate, exhaustion all work)
6. Docker E2E                           DONE — full pipeline: upload → L402 paid fetch → tip → receipt submit → epoch settle


================================================================================
DIVERGENCES (code vs mvp_plan.md — fix before or during Sprint 7b)
================================================================================

Audit date: 2026-02-09. Cross-referenced all completed code against MVP plan spec.

## Fee Model — FIXED

[x] Volume-tapering founder royalty     replaced flat 5% (TIP_PROTOCOL_FEE_PCT) with r(v) formula
    - packages/physics/src/royalty.ts: founderRoyaltyRate(), computeRoyalty(), cumulativeFounderIncome()
    - apps/coordinator/src/views/bounty-pool.ts: creditTip() now queries cumulative volume, applies formula
    - constants.ts: FOUNDER_ROYALTY_R0=0.15, V_STAR=125M, ALPHA=log(2)/log(9)
    - removed: TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
    - 170/170 tests pass

## Pool Key (blocks event/topic funding)

[!] BountyPool keyed by CID only
    - Code: Prisma BountyPool.cid: String @id; all routes use /bounty/:cid
    - Plan: pool_key = bytes32 (can be CID, event_id, or topic hash)
    - Fix: Sprint 7b. Rename BountyPool.cid → BountyPool.poolKey. Accept any bytes32.

## Gateway Endpoints (missing 2 from interface spec)

[!] No GET /cid/{hash} unified endpoint
    - Code: only /block/:cid, /file/:root, /asset/:root
    - Plan: "Events ≤ CHUNK_SIZE_DEFAULT are nano-blobs — fetched via GET /cid/{event_id}"
    - Fix: Sprint 7b. Add GET /cid/:hash → if single block, serve; if asset, 302 to /asset/.

[!] No free preview tier
    - Code: dev mode = all free; prod = all L402. No size-based free serving.
    - Plan: "Thumbnails/excerpts ≤16 KiB served without L402, rate-limited per-IP"
    - Fix: Sprint 7b. Blocks ≤ FREE_PREVIEW_MAX_BYTES served without L402 when host opts in.

## PricingV1 Schema — FIXED

[x] PricingV1 now has all 6 fields   burst_sats_per_gb, min_bounty_sats, sats_per_gb_month, open_min_pool_sats
    - packages/physics/src/schemas/host.ts: 4 new Optional() fields added
    - all backward-compatible (existing 2-field PricingV1 still valid)

## Constants — MOSTLY FIXED

[x] Stale constants removed            TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
[x] Royalty constants added             FOUNDER_ROYALTY_R0, V_STAR, ALPHA
[x] PricingV1 constants added          BURST_SATS_PER_GB, MIN_BOUNTY_SATS_DEFAULT, OPEN_MIN_POOL_SATS_DEFAULT
[x] Event constants added              EVENT_POW_TARGET, EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES
[x] AGGREGATOR_FEE_PCT added to plan   MVP default (3%), market-determined post-MVP

Plan constants still missing from code (add during relevant sprint):
    - BASE_FEE = 21-210 sats                  → Sprint 7b (EventV1 ingest, dynamic pricing)
    - SNAPSHOT_INTERVAL_EPOCHS = 100          → Sprint 7d.1
    - ANCHOR_INTERVAL_EPOCHS = 6             → Sprint 7d.1
    - PREVIEW_THUMB_WIDTH = 200              → Sprint 7e
    - PREVIEW_TEXT_CHARS = 500               → Sprint 7e

## Schema Gaps (non-blocking, fix during relevant sprint)

[ ] EpochSummary missing receipt_merkle_root    → Sprint 7d.1 (snapshot/compaction)
[ ] DirectoryV1 missing regions[], refusals_cid, materializers[]  → Sprint 7b
[ ] No MaterializerV1 / MaterializerPricingV1 schema  → Sprint 7b
[ ] No EventV1 TypeBox schema (this IS Sprint 7b)
[ ] Pin cancel: no SLA-triggered fee waiver    → Sprint 7b (needs SLA monitoring)
[ ] GET /served endpoint missing               → Sprint 7b (low priority)
[ ] Node-agent doesn't publish min_bounty_sats → Sprint 7b (after PricingV1 fix)

## False Positive in Progress Log — FIXED

[x] sats_per_gb_month now in TypeBox schema (host.ts) as Optional field. Progress log corrected.

## Codebase Review Fixes (2026-02-09)

[x] Bug: INACTIVE→TRUSTED transition   host-registry.ts — INACTIVE hosts that recover now transition back
[x] Bug: mirror multi-block assets     node-agent/mirror.ts — resolves AssetRoot→Manifest→blocks (was single-block only)
[x] Bug: mint input validation         mint/server.ts — POST /sign now validates all 6 fields (was crashing on undefined)
[x] Bug: invoice store leak            gateway/server.ts — cleanup() now called every 60s via setInterval + onClose hook
[x] Dead code: satsPerGb passthrough   gateway/routes/block.ts — removed from BlockRouteContext (flat minRequestSats is correct)
[x] Test: royalty.ts coverage          16 new tests: formula at plan anchor points, monotonicity, edge cases, input guards
[x] Test: availability transition      fixed test expectation: score=0 → INACTIVE (not DEGRADED) per plan lifecycle
    Total: 186/186 tests pass (was 170)


================================================================================
PATH A: DEPLOY + CLI (get content flowing)
================================================================================

Goal: founder can upload seed content, share links, people can fetch via L402.
DocRef: MVP_PLAN:§Bootstrap Sequence (Week 1-2), §What Layer A Markets Need

## Sprint 7 — CLI client (apps/cli)

The minimum tool for a human to use the protocol without curl.
Wraps the HTTP API into a command-line workflow.

[x] Project scaffold                    apps/cli, TypeScript, imports @dupenet/physics, commander
[x] `dupenet upload <file>`             chunk → PUT /block × N → PUT /file → PUT /asset → print asset_root
    - chunker + manifest + asset root construction (reuse physics)
    - multi-block upload with progress indicator
    - MIME auto-detect from extension, auto kind (TEXT/IMAGE/AUDIO/VIDEO/FILE)
    - print shareable URL: https://<gateway>/asset/<root>
[x] `dupenet fetch <cid> [-o file]`     GET /asset → GET /file → stream GET /block × N → reassemble → write
    - auto-detect: raw CID (single block) vs asset_root (multi-block)
    - L402 flow: get 402 → pay invoice via LND REST → present preimage → receive bytes
    - --free flag fails instead of paying (for dev mode gateways)
    - SHA256 integrity verification on reassembly
[x] `dupenet tip <cid> <sats>`          sign tip → POST /tip → print bounty balance
    - Ed25519 sign from local keyfile (~/.dupenet/key.json)
    - print pool_credit + protocol_fee
[x] `dupenet pin create <asset_root>`   POST /pin → print pin_id, drain_rate
    - --budget, --duration, --copies flags
    - `dupenet pin status <pin_id>` → GET /pin/:id
    - `dupenet pin cancel <pin_id>` → POST /pin/:id/cancel
[x] `dupenet info <cid>`                GET /bounty/:cid + GET /asset/:root → print summary
    - bounty balance, asset metadata, gateway pricing
[x] `dupenet keygen`                    generate Ed25519 keypair → write to ~/.dupenet/key.json
    - reuse physics generateKeypair()
    - --force to overwrite existing
    - print pubkey hex
[x] `dupenet config`                    gateway URL, coordinator URL, key path, LND connection
    - ~/.dupenet/config.json
    - env var overrides (DUPENET_GATEWAY, DUPENET_COORDINATOR, DUPENET_KEY_PATH)
[x] `dupenet hosts`                     GET /directory → print host list + pricing + status
[x] LND payment integration             pay L402 invoices via LND REST (/v2/router/send)
    - connect to user's LND (REST, macaroon auth)
    - fallback: print invoice + prompt for manual wallet payment

Exit: `dupenet upload cat.jpg` → prints asset_root URL → `dupenet fetch <root> -o out.jpg` → identical file.
      `dupenet tip <root> 100` → bounty pool credited.

## Sprint 8 — Real deployment (founder stack on VPS)

The founder stack moves from Docker-on-laptop to a public server.
DocRef: MVP_PLAN:§Node Kit, §What Hosts vs What You Host, §Bootstrap Sequence, §Infrastructure Partners

[x] VPS provisioning                    FlokiNET Romania (4 CPU, 4GB RAM, 90GB NVMe, 9TB BW, DDoS prot.)
[x] Domain acquired                     ocdn.is (ISNIC Iceland — ccTLD, seizure-proof, WHOIS privacy)
[~] DNS A record                        ocdn.is → 185.165.169.8 (pending ISNIC activation)
[x] compose-production.yml              signet LND, hardened Postgres, restart policies, no regtest services
[x] Caddyfile.production                ocdn.is domain, automatic HTTPS via Caddy/Let's Encrypt
[x] scripts/deploy.sh                   one-shot server setup (Docker, git, keys, firewall)
[x] scripts/backup.sh                   Postgres dump + LND SCB, 14-day retention, cron-ready
[x] .env.example updated                production DB creds, signet macaroon paths, ocdn.is endpoint
[ ] Server access                       VPS provisioned, awaiting Proxmox lock clear (FlokiNET support)
[ ] Docker + stack deploy               deploy.sh → compose-production.yml up
[ ] LND signet wallet                   create wallet, fund via signet faucet, open channel
    - decision: signet first, flip to mainnet when confident
[ ] Mint 1 operational                  co-located on founder VPS (Romania)
[ ] Mint 2 (remote)                     separate VPS in Malaysia (Shinjiru) or Switzerland (COIN.HOST)
[ ] Mint 3 (remote)                     third jurisdiction — add before public announcement
[ ] Seed content upload                 founder uploads Tier 1 + Tier 2 content via CLI
[ ] Shareable URLs                      https://ocdn.is/asset/<root> returns content
[ ] Monitoring                          uptime check, LND balance alerts, disk usage
[ ] Backup cron                         schedule scripts/backup.sh every 6h
[ ] Multi-endpoint client config        CLI + node-agent: endpoints[] array, retry-with-rotation
[ ] Hardcoded bootstrap list            founder endpoints built into CLI binary
[ ] .onion address                      Tor hidden service in compose-production.yml
[ ] Second domain                       separate registrar/TLD pointing to same or different IP
[ ] peers.json rolling cache            ~/.dupenet/peers.json updated on every successful interaction
[ ] Daily Bitcoin anchoring (L7)        1 tx/day, Taproot tweak, epoch_summary + snapshot hash
    - infrastructure side; UI verify page + crisis readiness in Sprint 7e

Exit: public URL serves real content via L402. External client can `dupenet fetch` from anywhere.
      Client survives founder endpoint outage via retry-with-rotation + cache + .onion fallback.
      Daily Bitcoin anchor makes all protocol state verifiable. Crisis spike degrades gracefully.

## Sprint 9 — Multi-host (prove the network)

Second host connects to the founder's coordinator and mirrors content.
DocRef: MVP_PLAN:§Node Kit (Target: Raspberry Pi), §Bounty Pool Mechanics

[ ] Second VPS (or Pi)                  deploy compose-nodekit.yml pointing at founder coordinator
[ ] Node-agent mirrors content          agent discovers bounty feed, mirrors top CIDs from founder gateway
[ ] Directory shows 2 hosts             GET /directory lists both with pricing + availability
[ ] Spot-checks pass                    coordinator verifies second host has blocks (GET /spot-check)
[ ] Failover works                      kill host 1 → client retries host 2 → content still available
[ ] CLI host selection                  `dupenet fetch` picks cheapest/fastest host from directory
[ ] Receipt flow from second host       L402 fetch from host 2 → receipt → epoch settlement includes both hosts

Exit: two independent hosts serve the same CID. Kill one, content survives. Receipts flow from both.


================================================================================
PATH A.1: EventV1 + REFERENCE MATERIALIZER (no VPS dependency — build while waiting)
================================================================================

Goal: collapse all non-blob, non-receipt protocol actions into EventV1 envelope.
Build reference materializer that interprets kind bytes. Content becomes discoverable,
fundable, and discussable via one endpoint (POST /event) and one query (GET /events).
DocRef: MVP_PLAN:§Protocol vs Materializer Boundary, §Event Layer, §Event Kind Payload Conventions

Architectural decision (2025-02-08):
  - Protocol surface area is the enemy. Proof-of-service is sacred. Everything else is views.
  - EventV1 { v, kind, from, ref, body, sats, ts, sig } is the only non-blob protocol primitive.
  - Protocol rule: if event.sats > 0, credit pool[event.ref] += sats. That's it.
  - Kind interpretation, threading, ranking, author rewards, pin lifecycle, moderation = materializer.
  - Tip / upvote / fortify / pin are all the same action: POST /event with sats > 0.
  - Pins are kind=PIN_POLICY events with drain policy in body. Materializer enforces SLA.
  - Author earnings: not in protocol. Authors self-host (earn as hosts) or earn via materializer bonuses.
  - Existing POST /tip, POST /host/register, POST /content/announce → collapse into POST /event.
  - ReceiptV2 + epoch settlement untouched. Don't fix what's not broken.

## Sprint 7b — EventV1 Envelope (packages/physics)

The protocol-level event primitive. Everything in materializer depends on this.
ALSO: fixes all divergences marked "Sprint 7b" in §DIVERGENCES above.

[ ] EventV1 TypeBox schema             { v: u8, kind: u8, from: bytes32, ref: bytes32, body: bytes, sats: u64, ts: u64, sig }
    - canonical serialization (same pattern as existing schemas)
    - event_id = SHA256(canonical(EventV1 minus sig))
    - Ed25519 signature: sign/verify canonical(EventV1 minus sig)
    - body: inline ≤16 KiB (kind-specific payload)
    - sats: economic weight (0 = free statement, >0 = pool credit)
[ ] Kind byte constants                0x01 FUND, 0x02 ANNOUNCE, 0x03 POST, 0x04 HOST, 0x05 REFUSAL,
                                       0x06 ATTEST, 0x07 LIST, 0x08 PIN_POLICY, 0x09 MATERIALIZER
[ ] Kind payload schemas (TypeBox)     AnnouncePayload, HostPayload, ListPayload, PinPayload
    - these are materializer conventions, not protocol — live under physics for convenience
    - unknown kinds: preserve, don't reject (extensibility)
    - AnnouncePayload.access: "open" | "paid" (default "paid") — publisher intent for open-access serving
      "open" = full content served without L402 (hosts earn from bounty pool only)
      materializer renders inline vs behind paywall based on this field
      see MVP_PLAN:§New User Journey (First Contact), §Open Access Tier
[ ] PricingV1.open_min_pool_sats       host-configured threshold for open-access serving
    - pool below threshold → host declines open-access, falls back to L402
    - prevents free-CDN abuse: open access is sponsored availability, not charity
    - default: 500 sats (OPEN_MIN_POOL_SATS_DEFAULT in constants)
    - add to existing PricingV1 schema alongside min_bounty_sats
[ ] Pool credit rule                   if event.sats > 0: credit pool[event.ref] += sats (minus protocol fee)
    - pool_key = event.ref (bytes32 — can be CID, event_id, topic hash)
    - protocol is key-blind; materializer resolves ref → CID for settlement
[ ] EventV1 tests                      construct, sign, verify; pool credit; reject forged/missing sig
[ ] Migrate existing events            TipV1 → kind=FUND, HostServeV1 → kind=HOST, HostRegisterV1 → kind=HOST
    - backward compat: existing POST /tip, POST /host/register still work (shim to POST /event)
    - new canonical path: POST /event (accepts any kind)

Divergence fixes (bundled into this sprint — see §DIVERGENCES):
[x] Replace fee model                  DONE — royalty.ts + bounty-pool.ts + constants.ts. 170/170 tests pass.
[x] PricingV1 complete                 DONE — 4 new Optional fields in TypeBox schema. Constants added.
[x] New constants                      DONE — EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES, EVENT_POW_TARGET.
[ ] Pool key → bytes32                 rename Prisma BountyPool.cid → poolKey. Accept CID/event_id/topic_hash.
[ ] GET /cid/:hash endpoint            gateway: if single block → serve; if asset → 302 to /asset/. Nano-blob path.
[ ] Free preview tier                  blocks ≤ FREE_PREVIEW_MAX_BYTES served without L402. Rate-limit per-IP.
[ ] BASE_FEE                           21-210 sats (dynamic, EIP-1559 style) — EventV1 ingest pricing.
[ ] Node-agent publishes min_bounty_sats  in PricingV1 during host registration.

Exit: physics exports EventV1. Construct event, sign, verify. Pool rule tested.
      Kind payloads constructable/verifiable. One envelope replaces per-action schemas.
      Fee model is volume-tapering royalty, not flat 5%. Pool keys accept any bytes32.
      Gateway serves nano-blobs via GET /cid/:hash. Free preview tier works.
      PricingV1 has all 6 fields.

## Sprint 7c — Batch Upload + Content Metadata (apps/cli)

The whistleblower flow: upload a directory of PDFs with human-readable metadata.
All publishing now goes through POST /event with appropriate kind bytes.

[ ] `dupenet upload <dir>`              batch upload: chunk + upload each file in directory
    - recursive traversal, filters by known MIME types
    - progress: file N/M, blocks K/T overall
    - skip already-uploaded blocks (409 Conflict = ok, resume on failure)
    - after upload: POST kind=ANNOUNCE event per file, POST kind=LIST event for collection
[ ] Upload metadata flags               --title, --description, --tags, --language, --source, --access open|paid
[ ] Thumbnail generation                generate preview thumbnails client-side (images: 200px JPEG; text: 500 char excerpt)
[ ] `dupenet fund <ref> <sats>`         unified funding command (replaces `dupenet tip`)
    - POST /event with kind=FUND, sats=amount, ref=pool_key
    - works for any ref: CID, event_id, topic hash
    - materializer resolves LIST refs → fan-out across constituents
[ ] `dupenet post <ref> <text>`         publish threaded text (kind=POST)
    - ref = parent event_id (reply) or topic hash (root post)
    - body = inline text ≤16 KiB
    - optional --sats flag to boost own post

Exit: `dupenet upload ~/leak/ --title "Court Filings" --tags epstein,legal`
      → uploads 200 PDFs, publishes ANNOUNCE + LIST events, prints collection URL.
      `dupenet fund <list_event_id> 10000` → credits pool. One endpoint.
      `dupenet post <event_id> "This proves X"` → threaded reply published.

## Sprint 7d — Signal Aggregation + Market Quoting (apps/coordinator — reference materializer)

Materializer views over EventV1 stream. These are product features, not protocol.
All endpoints are materializer conventions — other materializers may offer different views.

[ ] POST /event                         unified event ingest endpoint
    - validate EventV1 sig
    - if sats > 0: credit pool[ref]
    - index by kind, ref, from, ts
    - rate-limit per pubkey/IP (MVP spam defense; paid ingest later)
[ ] GET /events?ref=&kind=&from=&since= generic event query (replaces per-kind GET endpoints)
[ ] Prisma model: Event                 { id, kind, from, ref, body, sats, ts, sig, event_id }
    - indexes: (ref), (kind, ts), (from, ts), (event_id unique)
[ ] GET /feed/recent                    recent ANNOUNCE events (paginated, filterable by tags)
[ ] GET /feed/funded                    pool_keys ranked by balance (replaces GET /bounty/feed)
[ ] GET /host/:pubkey/scorecard         host reputation (from HOST events + spot-checks + receipts)
[ ] GET /content/:ref/signals           content resilience + graph importance (dual score)
[ ] GET /author/:pubkey/profile         pseudonymous reputation (events by pubkey + demand on their content)
[ ] GET /market/quote                   supply curve from host min_bounty_sats thresholds
[ ] GET /thread/:event_id               thread view: resolve ref chain from kind=POST events, return tree
[ ] GET /cluster/:ref?hops=N            graph neighborhood: all nodes within N hops via ref/body/list edges
[ ] Body edge extraction                parse [ref:bytes32] tokens from POST/ANNOUNCE bodies at ingest
    - Prisma model: BodyEdge { source_event_id, target_ref, edge_sats }
    - index: (target_ref) for inbound citation queries
[ ] Graph importance computation        weighted PageRank over citation DAG (ref + body + list edges)
    - incremental: recompute affected neighborhoods on new events
    - expose via GET /content/:ref/signals (graph_importance field)
[ ] Event-to-blob promotion             funded events above threshold serialized as CIDs → PUT /block
    - materializer policy: threshold configurable (e.g. 1000 sats)
    - promoted events enter normal replication market
[ ] GET /orphans                        three-part orphan score: high direct pool + low graph connectivity
                                       (few inbound ref/body edges from funded events) + low discussion depth
                                       (few/zero kind=POST replies). "Funded, but under-analyzed." Analyst job board.
                                       Hard to game: inflating pool costs real sats, reducing connectivity means
                                       not linking to the node (defeats visibility gaming).

Exit: POST /event accepts all kinds. GET /events returns filtered stream.
      GET /feed/funded ranks by dual score (direct pool + graph importance).
      GET /cluster/<ref> returns citation neighborhood. GET /orphans surfaces undiscussed funded content.
      GET /thread/<id> returns discussion tree. Signal endpoints are materializer views — not protocol.

## Sprint 7d.1 — Event Log Compaction + Snapshot Bootstrap (packages/physics + apps/coordinator)

Unchanged in scope. Snapshots now cover pools (keyed by ref) instead of bounty pools (keyed by CID).
DocRef: MVP_PLAN:§Event Log Growth + Compaction, §Longevity L7

[ ] StateSnapshotV1 schema             physics: epoch, merkle roots for pools / hosts / events / serves, event_count, prev_hash
[ ] Merkle tree library                physics: build from sorted key-value pairs, generate/verify inclusion proofs
[ ] Snapshot generator                 coordinator: materialize Prisma state into StateSnapshotV1
[ ] GET /snapshot/latest, GET /snapshot/:epoch, GET /snapshot/:epoch/proof/:key
[ ] Receipt rollup in epoch settlement EpochSummary stores receipt merkle_root + counts only
[ ] GET /bootstrap                     fast node sync: latest snapshot + events since
[ ] Snapshot verification              publisher sig (MVP), Bitcoin-anchored epoch root (L7)
[ ] Snapshot + inclusion proof tests

Exit: GET /bootstrap returns snapshot + recent events. New node materializes in seconds.

## Sprint 7e — The Leaderboard + Web Surface (the product)

The global importance scoreboard — content ranked by economic commitment. The product that
drives adoption, distribution, funding, and institutional revenue. The new user journey
(MVP_PLAN:§New User Journey) lives or dies here.
DocRef: MVP_PLAN:§The Leaderboard (Step 8), §New User Journey (First Contact)

### Minimum ship (4 pages)

[ ] Scaffold web app                   apps/web, Next.js, server-renders from materializer APIs

[ ] / Leaderboard
    - rows: title, pool sats, copies, Fortify button
    - top bar: total sats, host count, "live" indicator
    - SSE: pool balance + rank updates (this IS the activity feed at low volume)

[ ] /v/<ref> Content page
    - inline render if access="open", else excerpt/thumbnail + L402
    - 3 stats: pool sats, copies, runway (months at current drain)
    - Fortify button: amount selector (21/210/2100/custom) + WebLN/QR
    - thread: list comments (kind=POST with ref=this) + comment box (PoW for free, sats to boost)

[ ] /c/<list> Collection page
    - list items: title, pool, copies
    - Fund All button (size-weighted default)

[ ] /p/<ref> Proof page
    - hash verified badge
    - Bitcoin anchor txid + date
    - host endpoints list
    - download evidence bundle (EvidenceExportV1 JSON)

### Next pass (add after 4 pages prove the loop)

[ ] Topic leaderboards: /topic/<tag>   tag filter on leaderboard, not separate page
[ ] Cluster page: /g/<ref>             graph neighborhood (needs enough edges to be useful)
[ ] Thread page: /t/<event_id>         separate thread view (threads already render on /v/<ref>)
[ ] Thread bundle page: /b/<bundle_cid> archived conversation snapshot
[ ] Orphan filter                      "sort by: needs analysis" on leaderboard (not separate page)
[ ] Host scorecard: /h/<pubkey>        operator-facing, add when there are operators
[ ] Embeddable widget                  distribution mechanism, add after loop is proven
[ ] Velocity indicators, collection sort/filter, inbound/outbound citation counts
[ ] Fund Thread button                 fan-out over ref-chain (cheap to add, but comment+Fortify first)
[ ] Market quote tooltip               "+X sats → est. +Y replicas" on Fortify button

### Client interaction model (MVP_PLAN:§Client Interaction Model)

[ ] Browser keypair lifecycle           generate Ed25519 on first write → indexedDB (encrypted) + localStorage (pk)
    - identity chip UI: pubkey short, export/import, NIP-07 detect, reset
    - "no key" mode: read-only browsing, write prompts key creation (1 tap)
    - NIP-07 upgrade: if window.nostr present, prefer it for signing
[ ] Event construction in browser       physics library must work in browser (already uses @noble/hashes — OK)
    - EventV1 compose → sign → POST /event (same pipeline for comment/fund/announce/list)
[ ] Event PoW (Web Worker)             free writes: PoW in Web Worker, never block UI, "publishing..." spinner
    - challenge = SHA256("EV1_POW" || from || ts || kind || ref || SHA256(body))
    - find nonce where H(challenge || nonce) < EVENT_POW_TARGET (~200ms mobile)
    - distinct from receipt PoW (different prefix, different purpose)
[ ] Payment-intent binding              POST /payreq { sats, event_hash } → invoice with event_hash in memo
    - materializer rejects events whose hash doesn't match paid invoice
[ ] Upload shim (MVP)                  POST /upload (multipart) → materializer chunks → returns asset_root
    - metadata events (ANNOUNCE/LIST) always signed client-side
    - returns identical objects to client-side chunking (drop-in swap later)
[ ] SSE endpoints                      GET /sse/global (leaderboard), GET /sse/ref/<ref> (per-content)
    - message types: fund_delta, new_event, replica_change, rank_shift
    - optimistic UI insert on submit, reconcile on SSE echo
[ ] Pending event queue                indexedDB: signed events stored offline, replay on reconnection, dedup by event_id
    - connects to §Longevity L2 (client-side event buffer)

### Fortify payment flow (MVP_PLAN:§New User Journey — zero-to-sats)

[ ] WebLN auto-pay (tier 1)            Fortify → amount selector (21/210/2100/custom) → WebLN pays → done
[ ] QR/invoice fallback (tier 2)       no WebLN → QR code + invoice string → scan in wallet app
[ ] Wallet guide (tier 3)              no wallet → one-screen guide (Phoenix/Alby). Accept bounce-and-return.
[ ] Fortify abandonment tracking        measure clicks → completions per tier. Fiat bridge trigger: >60% abandon.

### Bitcoin integrity anchor (L7 — pulled into MVP)

[ ] Daily Bitcoin tx                   Taproot tweak: SHA256(epoch_summary_merkle_root || state_snapshot_hash)
    - batched: 1 tx/day covering 6 epochs. ~$0.50/day.
[ ] Verify page: /verify/<ref>         paste CID or event_id → inclusion proof path → Bitcoin tx link
    - "integrity radiator" — institutions won't touch without it

### Crisis readiness (before first spike)

[ ] Read-only mode                     one switch: disable writes, keep serving reads
[ ] Hot-path cache                     top 100 leaderboard items cached, invalidated on new events
[ ] Rate limiting                      materializer API per-IP (L402 surge pricing at volume)
[ ] Status page                        public uptime/health endpoint + incident comms template
[ ] Graceful degradation               widget and API serve cached data if coordinator overloaded

Exit: 4 pages ship. / shows leaderboard with live SSE updates. /v/<ref> shows content (open-access
      inline, paid behind L402), 3 stats, Fortify (WebLN+QR), comment box. /c/<list> shows collection
      with Fund All. /p/<ref> shows proof with Bitcoin anchor + evidence download.
      New user journey core loop works: arrive → read → fund → comment → prove.


================================================================================
PATH B: S3 ADAPTER (platform adoption)
================================================================================

Goal: existing apps switch to dupenet storage with a config change.
DocRef: MVP_PLAN:§S3-Compatible Adapter (Layer A — Migration Unlock)

## Sprint 10 — S3-compatible adapter (apps/s3-adapter)

Thin shim that speaks S3 protocol and translates to the blob layer.
Single-tenant: runs alongside the consuming app, talks to one gateway.

[ ] Project scaffold                    apps/s3-adapter, TypeScript + Fastify (or http)
[ ] Auth layer                          S3 access key → protocol pubkey mapping (thin translation)
    - single-user mode for MVP (one access key)
    - SigV4 signature verification (just enough to satisfy AWS SDKs)
[ ] PUT object → chunk + upload         receive S3 PutObject → chunk file → PUT /block × N → PUT /file → PUT /asset
    - compute asset_root, return as ETag
    - handle multipart uploads (S3 multipart → map to block uploads)
    - chunking reuses @dupenet/physics
[ ] GET object → resolve + stream       S3 GetObject → GET /asset → GET /file → stream GET /block × N
    - reassemble blocks into response stream
    - Range header support (partial reads)
    - Content-Type from AssetRoot mime
[ ] HEAD object                         S3 HeadObject → HEAD /asset → return size, content-type, ETag
[ ] DELETE object                       return 204 (no-op; content-addressed = no true delete)
[ ] LIST objects                        return list of known asset_roots (local cache)
    - or: return empty (many apps don't need LIST)
[ ] Bucket abstraction                  all objects in one "bucket" (single gateway = single bucket)
[ ] Integration test                    `aws s3 cp` in, `aws s3 cp` out, `aws s3 ls` → identical bytes
[ ] Docker image                        add to compose-founder.yml as optional service

Exit: `aws s3 cp file.tar s3://dupenet/file.tar` succeeds.
      `aws s3 cp s3://dupenet/file.tar -` returns identical bytes.
      No code changes in the consuming app.

## Sprint 11 — SDK + documentation

Make Layer A consumable by external developers.
DocRef: MVP_PLAN:§Receipt Verification SDK, §Adoption Path

[ ] receipt-sdk published               npm publish @dupenet/receipt-sdk (zero deps, works everywhere)
[ ] physics published                   npm publish @dupenet/physics (or subset: canonical, cid, chunker)
[ ] HTTP API reference                  OpenAPI/Swagger spec for gateway + coordinator endpoints
    - generated from route definitions or hand-written
    - hosted at docs.dupenet.dev
[ ] Integration guide                   "Store files on dupenet in 5 minutes"
    - code samples: upload, fetch, tip, pin
    - S3 adapter setup guide
[ ] Receipt verification guide          "Verify paid consumption in your app"
    - import receipt-sdk → verify receipts → rank content / gate access
    - cross-platform use cases (Nostr, forums, media apps)
[ ] Pin contract guide                  "Pay for durability"
    - create pin, monitor copies, cancel/refund flow

Exit: a developer who has never seen the codebase can integrate in <1 hour.


================================================================================
REMAINING POLISH (non-blocking, do when convenient)
================================================================================

[ ] EXIF/metadata stripping             strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation           TypeBox schemas defined but Value.Check not called on ingest
[ ] Stake locking via LND               verify stake payment on host registration (currently stubbed)
[ ] Deterministic Docker builds         Nix flake or pinned multi-stage (DocRef: MVP_PLAN:§Longevity L6)
[ ] Epoch root anchoring                Bitcoin tx per epoch: SHA256(epoch_summary_root || snapshot_hash) (DocRef: MVP_PLAN:§Longevity L7)
    - makes state snapshots trustlessly verifiable (no need to trust coordinator)
    - depends on Sprint 7d.1 (snapshot format must exist first)
    - Taproot tweak or OP_RETURN, ~$0.50/day at 1 tx/day covering 6 epochs

External review fixes (solved — applied to mvp_plan.md):
[x] FileManifest merkle_root            real binary Merkle tree (leaf hash + pair hash), not SHA256(concat) (#1)
    - enables inclusion proofs, streaming verification, partial block validation
[x] Stake language: custodial            "deposited with coordinator — custodial in MVP" (#4)
    - post-MVP: on-chain UTXO, federation, or DLC-based escrow
[x] Free preview rate limiting           per-IP token bucket (60 burst / 10 sustained); CDN for founder hosts (#6)
    - hosts can disable free tier; MUST rate-limit if enabled
[x] Storage pricing knob                 sats_per_gb_month: u64? added to PricingV1 TypeBox schema (host.ts)
    - enables durability estimation: (bounty - egress_drain) / (storage_cost * size_gb) = months
[x] Pin SLA semantics                    best effort + full refund if min_copies unmet 6 epochs (#10)
    - no PIN_CANCEL_FEE on SLA-triggered cancel; regions relaxable via signed amendment


================================================================================
POST-MVP ASSESSMENT (deferred from external review, assess after launch)
================================================================================

DocRef: MVP_PLAN:§Post-MVP Assessment Queue

[ ] Event spam pricing                 decide: paid ingest (402-gated POST /event) vs rate-limited + PoW
    - MVP: materializer rate-limits per pubkey/IP (sufficient at founder scale)
    - POST kind=POST (threaded comments) especially needs friction: PoW min, optional sats
    - assess once real event volume + abuse patterns visible
    - paid ingest funds materializers (product toll, not protocol toll)
    - PoW per event acceptable for humans; evaluate impact on automated publishers

[ ] min_bounty_sats quote gaming       compute behavioral thresholds from HostServe event data
    - MVP: founder knows all hosts, gaming irrelevant
    - post-MVP: observed_threshold = min bounty at which host first served a CID
    - show confidence intervals (self-reported vs observed) when data sufficient
    - separately evaluate slashable signed quotes (expands slash surface beyond crypto fraud)
    - trigger: host count > 50 and supply curve UI is live

[ ] Multi-source parallel download     client fetches blocks from multiple hosts simultaneously
    - MVP: single-host fetch with failover (sufficient for 2-3 hosts)
    - protocol already supports it (block-level addressing + multiple hosts per CID)
    - deferred: partial-file payment economics, block availability bitmap, stripe strategy
    - trigger: 3+ hosts serve the same CID in production

[ ] Receipt privacy (ephemeral pubkeys) clients SHOULD use one-time keypairs for receipt submission (#5)
    - receipt submission already opt-in; casual readers (L402 only) have no protocol exposure
    - ephemeral pubkeys don't weaken anti-sybil: hard defense is economic (L402 cost + mint token),
      not identity-based (key generation is free; PoW escalation per-pubkey already trivially bypassed)
    - RECEIPT_MIN_UNIQUE=3 is a tripwire, not a wall (3 throwaway keys cost zero)
    - lean on payment-based diversity signals: distinct payment_hash, temporal spread, graph breadth
    - aggregator remains MVP privacy trust point (same as all founder dependencies)
    - long-term: blinded/bearer receipts (Cashu-style) for zero-knowledge demand proofs
    - spec updated: MVP_PLAN:§Receipt Privacy (DocRef: MVP_PLAN:§Fetch Flow, §Host Self-Farming)

[ ] Audit griefing hardening            cap frequency, deterministic target selection (#9)
    - cap audit frequency per (host, cid, epoch) — prevents bandwidth griefing
    - PRF-based audit target selection (auditable but unpredictable to host)
    - L402 cost already gates spam audits; separate auditor bond adds complexity, defer
    - regional selective failure (honest to auditor IPs, corrupt to others): operational fix (Tor), not protocol fix
    - trigger: audit volume becomes meaningful (>100 audits/day)

[ ] Client safety layer                 layered pre/post-fetch safety, no sandboxing (#11)
    - mirrors operator attestation model (§Operator Content Policy) applied to client side
    - pre-fetch: MIME-type gate (warn on executables/scripts), publisher signal display, CID denylist
    - post-fetch: SHA256 verify (already in spec), magic bytes vs declared MIME, known-good list check
    - ClientPolicyV1 schema: attester_follow, mime_warn, mime_block, trusted_publishers, threshold
      same import/export format as operator policy JSON
    - known-good lists = signed kind=LIST events from projects (code signing via CIDs)
    - encrypted blobs opaque to attesters — packs only work for known-flagged unencrypted CIDs
    - out of scope: OS-level sandboxing, content rating, server-side scanning, global blocklist
    - applied to mvp_plan.md: new §Client Safety Layer section
    - trigger: first malware incident in production

[~] Materializer market + paid ingest   materializers = metadata hosts, same L402 economics (#12 + A)
    - key insight: materializer is a host for metadata — ingest events (POST /event),
      serve queries (GET /events, GET /feed, GET /thread). Same L402, same market.
    - EventV1 envelope + kind bytes formalized (2025-02-08 architectural decision)
    - kind=MATERIALIZER event for discovery; MaterializerPayload in kind conventions
    - MVP: founder is sole materializer; free ingest (rate-limited), free queries
    - author rewards = materializer product feature (rebate/bonus from materializer fees), NOT protocol
    - remaining design work (post-MVP, trigger: second materializer operator):
      - relay-vs-materializer economic separation at scale
      - consistency model for divergent materializer state
      - economic tuning: ingest fee vs query fee balance

[ ] Founder service replacement specs   inputs/outputs/swap procedure per service (B)
    - for each: directory, mints, aggregator, snapshots, provisioning, materializer
    - test: can a stranger replace it without "contact the founder"?
    - if not, the longevity section should say so honestly
    - trigger: pre-launch documentation pass


LEGEND: [x] done  [~] partial/stub  [ ] not started
