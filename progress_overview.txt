dupenet MVP — Progress Overview
================================

PHASE 1: BLOB UTILITY (Layer A)
--------------------------------

## Step 1 — File Layer + Gateway + HTTP Origin

[x] Canonical serialization          deterministic CBOR, sorted keys (packages/physics)
[x] CID computation                  SHA256-based content addressing
[x] Chunker                          256KiB blocks, reassembly
[x] Merkle tree                      binary merkle, odd-leaf promotion
[x] FileManifestV1 schema            TypeBox schema (chunk_size, size, blocks[], merkle_root)
[x] AssetRootV1 schema               TypeBox schema (kind, original, variants, meta)
[x] PricingV1 schema                 min_request_sats, sats_per_gb, burst
[x] Block storage backend            filesystem: {base}/{h[0:2]}/{h[2:4]}/{hash}
[x] PUT /block/:cid                  SHA256 verified on receive, rejects mismatches
[x] GET /block/:cid                  serves bytes; L402-gated when LND configured, free in dev mode
[x] PUT /file/:root                  validates file_root = SHA256(canonical(manifest)), checks all blocks exist
[x] GET /file/:root                  returns manifest (in-memory Map)
[x] PUT /asset/:root                 validates asset_root = SHA256(canonical(AssetRoot)), checks file exists
[x] GET /asset/:root                 returns asset (in-memory Map)
[x] HEAD /asset/:root                returns size, kind, mime headers
[x] GET /pricing                     returns PricingV1
[x] GET /health                      gateway health check
[x] Physics unit tests               canonical, cid, chunker, merkle, reward, epoch-aggregation, availability, block-selection, event-signature (9 suites, vitest)
[x] Gateway integration test          PUT /block xN -> PUT /file -> PUT /asset -> GET -> reassemble -> verify (7 tests)
[ ] EXIF/metadata stripping           strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation         TypeBox schemas defined but Value.Check not called on ingest

## Step 2 — L402 Paid Fetch + Receipt Minting

[x] Mint service structure            POST /sign, GET /pubkey, GET /health (apps/mint)
[x] Ed25519 keypair load              loads from MINT_PRIVATE_KEY_HEX env var
[x] Receipt token format              Sign("R2" || host || epoch || block_cid || response_hash || price || payment_hash)
[x] LND service in docker compose     lnd v0.18.5-beta + bitcoind regtest, 2-node (alice+bob) in compose-founder.yml
[x] LND config fields                 LND_HOST, LND_MACAROON_PATH, LND_TLS_CERT_PATH in gateway + mint config
[x] LND client package                packages/lnd-client: LndClient interface, REST impl, MockLndClient for tests
[x] L402 challenge-response           GET /block returns 402 + invoice -> pay with preimage -> bytes + receipt_token
[x] Invoice store                     in-memory TTL map (payment_hash -> {cid, price, host, epoch, expiry})
[x] Invoice generation                gateway creates invoice via LndClient.createInvoice()
[x] Mint settlement check             mint calls LndClient.lookupInvoice(), verifies SETTLED + amount >= price
[x] Mint HTTP client                  gateway calls POST /sign on mint, receives receipt_token
[x] min_request_sats enforcement      price = min_request_sats used for all block fetches
[x] L402 integration tests            8 tests: 402 challenge, paid fetch, invalid/unknown/mismatch/single-use (mock LND)
[x] Client PoW receipt minting        minePoW(), buildChallengeRaw/ClientSigPayload/TokenPayload in physics
[x] Block selection (anti-special)    selectBlockIndex(), selectBlock(), verifyBlockSelection() in physics (SHA256 PRF)

## Step 3 — Node Kit + Host Registration

[x] compose-founder.yml               gateway, mint, coordinator, postgres, lnd, caddy (all with healthchecks)
[x] compose-nodekit.yml               gateway, node-agent, caddy
[x] Coordinator structure             Hono server with routes, event log, materialized views
[x] POST /host/register               registers host (stub stake verification)
[x] GET /directory                     returns host list from in-memory Map
[x] Node-agent poll loop                discover profitable CIDs → mirror from source → announce serve (complete)
[x] Mirror agent                       findProfitableTargets() queries GET /bounty/feed; mirrorCid() fetches + pushes
[x] Directory announcement             announceHost() signed registration; announceServe() signed HostServe
[x] Availability score tracking        computeAvailabilityScore() in physics + updateAllScores() in coordinator
[x] Status lifecycle                   PENDING->TRUSTED (score>=0.6), TRUSTED->DEGRADED (score<0.6), ->INACTIVE (score==0)
[x] Spot-check responder              GET /spot-check/:cid on gateway (verifies hash, no L402, no bytes)
[x] Spot-check runner                 spotCheckHost(), runAllChecks() in coordinator (injectable fetcher)
[x] SpotCheck Prisma model            hostPubkey, cid, epoch, passed, latencyMs, error
[x] POST /hosts/check                 triggers spot-checks for all active hosts, updates scores
[x] GET /hosts/:pubkey/checks         returns check history + availability score + recommended status
[x] Availability tests                9 physics + 12 coordinator tests (scoring, transitions, spot-check runner)
[ ] Stake locking via LND              TODO: verify stake payment
[x] CID selection agent                queries GET /bounty/feed, filters by minBounty, mirrors top profitability CIDs

## Step 4 — Receipt Verification SDK

[x] VerifyReceiptV2 function           packages/receipt-sdk, full verification logic
[x] Ed25519 verify                     Web Crypto API, zero dependencies
[x] PoW hash check                     H(challenge || nonce) < TARGET validation
[x] Client signature check             Ed25519 sig over receipt payload
[x] Zero external dependencies         only crypto.subtle
[x] Test vectors                       valid e2e receipt (construct -> verify), invalid hex/PoW/token, wrong mint key (7 tests)

## Step 5 — Pin Contracts

[x] PinContractV1 schema               TypeBox schema (physics) + Prisma model
[x] POST /pin                           creates pin, computes drain_rate, credits bounty pool, logs event
[x] GET /pin/:id                        returns status, remaining budget, active hosts, copies_met, epoch proofs
[x] POST /pin/:id/cancel               returns remaining budget minus 5% fee, status -> CANCELLED
[x] Drain rate enforcement              drainPinBudgets() deducts min(actualDrain, drainRate) per epoch
[x] Budget management                   creditBountyDirect (no protocol fee); debitPayout on cancel refund
[x] Lifecycle transitions               ACTIVE -> EXHAUSTED (when remainingBudget=0); ACTIVE -> CANCELLED (on cancel)
[x] min_copies check                    getPinStatus compares active hosts vs min_copies, returns copies_met
[x] Epoch proof bundle                  getPinStatus returns recent EpochSummaryRecords for pinned asset (last 6 epochs)
[x] Pin contract tests                  22 tests: validation, create, status, cancel, drain rate, exhaustion
[x] Pin ID deterministic                SHA256(canonical(pin content)) — duplicate detection via unique constraint

COORDINATOR — PERSISTENCE + AGGREGATION
-----------------------------------------

[x] Prisma schema                      Event, BountyPool, Host, HostServe, EpochSummaryRecord, PinContract
[x] Prisma client generated            in Dockerfile (npx prisma generate)
[x] POST /tip                          credits bounty pool (in-memory Map, stub sig verification)
[x] GET /bounty/:cid                   reads from in-memory Map
[x] Event log writer                   in-memory array (not persisted)
[x] Bounty pool view                   in-memory Map
[x] Host registry view                 in-memory Map
[x] Epoch math                         packages/physics: epoch length 4h, current epoch, epoch boundaries
[x] Reward formulas                    cidEpochCap, computeHostScore, distributeRewards (physics)
[x] EpochSummary schema                defined in physics
[x] Coordinator -> Postgres             bounty-pool, host-registry, event-log all use PrismaClient (tsc clean)
[x] Event log persistence               append-only Postgres via prisma.event.create
[x] POST /receipt/submit                validates via receipt-sdk, checks epoch range + replay, stores in Prisma
[x] Receipt validation pipeline         verifyReceiptV2 checks client_sig, PoW, receipt_token against mint pubkeys
[x] Epoch aggregation (physics)         aggregateReceipts(), isPayoutEligible() — pure receipt grouping + 5/3 threshold
[x] Epoch settlement (coordinator)      settleEpoch() — aggregate receipts, compute payouts, drain bounty, persist EpochSummary
[x] POST /epoch/settle                  validates epoch is closed, calls settleEpoch(), idempotent (no double-spend)
[x] GET /epoch/summary/:epoch           returns settlement results for a given epoch
[x] Payout execution                    distributeRewards() called by settleEpoch(), rewards split by host score
[x] Bounty drain                        cidEpochCap() limits per-epoch drain, debitPayout() debits pool
[x] Aggregator fee                      3% deducted from cap before host distribution
[x] Epoch settlement tests              8 coordinator tests (mock Prisma) + 12 physics aggregation tests
[x] Epoch boundary trigger              createEpochScheduler() auto-settles closed epochs; configurable interval + spot-checks
[x] Signature verification on events    Ed25519 verify on POST /tip and POST /host/register; rejects forged/missing sigs

DOCKER / DEPLOY
-----------------

[x] compose-founder.yml                bitcoind + lnd-alice + lnd-bob + gateway + mint + coordinator + postgres + caddy
[x] compose-nodekit.yml                gateway + node-agent + caddy (separate Caddyfile)
[x] Dockerfiles (4 apps)               multi-stage node:20-alpine builds (gateway, mint, coordinator, node-agent)
[x] Coordinator entrypoint             prisma db push --skip-generate on startup (idempotent)
[x] LND credential sharing             lnd-data volume mounted read-only to gateway + mint
[x] LND REST wiring                    gateway + mint create LndRestClient when macaroon exists (dev mode fallback)
[x] @noble/ed25519 sha512 setup        mint signer configures sha512Sync from @noble/hashes
[x] Caddyfile.founder                  gateway + coordinator routes (/spot-check, /epoch, /hosts added)
[x] Caddyfile.nodekit                  gateway-only routes
[x] scripts/gen-keys.sh                generates Ed25519 keypairs (host + 3 mints), writes .env.local
[x] scripts/fund-lnd.sh                funds alice + bob, opens 1M sat channel
[x] scripts/e2e.sh                     E2E test skeleton (needs polish for receipt/settle path)
[x] Startup config echo                all 4 apps print config on boot (port, LND mode, mint keys, genesis)
[x] GENESIS_TIMESTAMP_MS env var       coordinator + gateway; enables epoch boundary control for testing
[x] @types/node for Docker builds      physics + receipt-sdk; fixes Web Crypto type errors in Docker context
[x] Buffer.slice() fix (ed25519)       wcBuf() helper handles cbor-x Buffer views correctly

INTEGRATION / E2E
------------------

[x] Gateway round-trip test             upload multi-block file, retrieve by asset_root, verify SHA256 (7 tests)
[x] L402 flow test                      402 -> pay invoice -> receive block + receipt_token (8 tests, mock LND)
[x] Docker E2E                          FULL PASS: upload → 402 → bob pays → block + receipt_token → tip → receipt submit → epoch settle ✓
[x] Receipt round-trip test             construct valid receipt (PoW + mint sig + client sig) -> verifyReceiptV2 passes
[x] Epoch settlement test              mock Prisma: eligible/ineligible hosts, bounty drain, idempotency, score split
[x] Pin contract test                  mock Prisma: create/status/cancel, drain rate, exhaustion, validation (22 tests)
[x] Availability test                  mock Prisma + mock fetcher: spot-check, scoring, transitions (12 tests)
[x] Event signature test               real Ed25519 keypairs: signed tip/register accepted, forged/missing rejected (7 tests)
[x] Bounty feed + host/serve test     bounty feed returns profitable CIDs; signed serve announcements (6 tests)
[x] Node-agent poll cycle test        mock fetch: discover, mirror, error handling (6 tests)
[x] Epoch scheduler test             mock Prisma: tick settles, idempotent, start/stop, error handling (7 tests)

SPRINT ORDER (Phase 1 — complete)
-----------------------------------

1. Gateway integration tests            DONE (7 tests pass)
2. L402 + mint settlement               DONE (8 tests pass, mock LND; Docker E2E with real LND in sprint 6)
3. Coordinator -> Postgres              DONE (tsc clean; requires `prisma db push` + Postgres to run)
4a. Receipt submission + validation     DONE (receipt-sdk e2e test passes; coordinator handler typechecks)
4b. Epoch aggregation + payout          DONE (20 new tests: 12 physics + 8 coordinator; bounty drains correctly)
5. Pin contracts lifecycle              DONE (22 new tests; create, cancel, drain rate, exhaustion all work)
6. Docker E2E                           DONE — full pipeline: upload → L402 paid fetch → tip → receipt submit → epoch settle


================================================================================
PATH A: DEPLOY + CLI (get content flowing)
================================================================================

Goal: founder can upload seed content, share links, people can fetch via L402.
DocRef: MVP_PLAN:§Bootstrap Sequence (Week 1-2), §What Layer A Markets Need

## Sprint 7 — CLI client (apps/cli)

The minimum tool for a human to use the protocol without curl.
Wraps the HTTP API into a command-line workflow.

[x] Project scaffold                    apps/cli, TypeScript, imports @dupenet/physics, commander
[x] `dupenet upload <file>`             chunk → PUT /block × N → PUT /file → PUT /asset → print asset_root
    - chunker + manifest + asset root construction (reuse physics)
    - multi-block upload with progress indicator
    - MIME auto-detect from extension, auto kind (TEXT/IMAGE/AUDIO/VIDEO/FILE)
    - print shareable URL: https://<gateway>/asset/<root>
[x] `dupenet fetch <cid> [-o file]`     GET /asset → GET /file → stream GET /block × N → reassemble → write
    - auto-detect: raw CID (single block) vs asset_root (multi-block)
    - L402 flow: get 402 → pay invoice via LND REST → present preimage → receive bytes
    - --free flag fails instead of paying (for dev mode gateways)
    - SHA256 integrity verification on reassembly
[x] `dupenet tip <cid> <sats>`          sign tip → POST /tip → print bounty balance
    - Ed25519 sign from local keyfile (~/.dupenet/key.json)
    - print pool_credit + protocol_fee
[x] `dupenet pin create <asset_root>`   POST /pin → print pin_id, drain_rate
    - --budget, --duration, --copies flags
    - `dupenet pin status <pin_id>` → GET /pin/:id
    - `dupenet pin cancel <pin_id>` → POST /pin/:id/cancel
[x] `dupenet info <cid>`                GET /bounty/:cid + GET /asset/:root → print summary
    - bounty balance, asset metadata, gateway pricing
[x] `dupenet keygen`                    generate Ed25519 keypair → write to ~/.dupenet/key.json
    - reuse physics generateKeypair()
    - --force to overwrite existing
    - print pubkey hex
[x] `dupenet config`                    gateway URL, coordinator URL, key path, LND connection
    - ~/.dupenet/config.json
    - env var overrides (DUPENET_GATEWAY, DUPENET_COORDINATOR, DUPENET_KEY_PATH)
[x] `dupenet hosts`                     GET /directory → print host list + pricing + status
[x] LND payment integration             pay L402 invoices via LND REST (/v2/router/send)
    - connect to user's LND (REST, macaroon auth)
    - fallback: print invoice + prompt for manual wallet payment

Exit: `dupenet upload cat.jpg` → prints asset_root URL → `dupenet fetch <root> -o out.jpg` → identical file.
      `dupenet tip <root> 100` → bounty pool credited.

## Sprint 8 — Real deployment (founder stack on VPS)

The founder stack moves from Docker-on-laptop to a public server.
DocRef: MVP_PLAN:§Node Kit, §What Hosts vs What You Host, §Bootstrap Sequence, §Infrastructure Partners

[x] VPS provisioning                    FlokiNET Romania (4 CPU, 4GB RAM, 90GB NVMe, 9TB BW, DDoS prot.)
[x] Domain acquired                     ocdn.is (ISNIC Iceland — ccTLD, seizure-proof, WHOIS privacy)
[~] DNS A record                        ocdn.is → 185.165.169.8 (pending ISNIC activation)
[x] compose-production.yml              signet LND, hardened Postgres, restart policies, no regtest services
[x] Caddyfile.production                ocdn.is domain, automatic HTTPS via Caddy/Let's Encrypt
[x] scripts/deploy.sh                   one-shot server setup (Docker, git, keys, firewall)
[x] scripts/backup.sh                   Postgres dump + LND SCB, 14-day retention, cron-ready
[x] .env.example updated                production DB creds, signet macaroon paths, ocdn.is endpoint
[ ] Server access                       VPS provisioned, awaiting Proxmox lock clear (FlokiNET support)
[ ] Docker + stack deploy               deploy.sh → compose-production.yml up
[ ] LND signet wallet                   create wallet, fund via signet faucet, open channel
    - decision: signet first, flip to mainnet when confident
[ ] Mint 1 operational                  co-located on founder VPS (Romania)
[ ] Mint 2 (remote)                     separate VPS in Malaysia (Shinjiru) or Switzerland (COIN.HOST)
[ ] Mint 3 (remote)                     third jurisdiction — add before public announcement
[ ] Seed content upload                 founder uploads Tier 1 + Tier 2 content via CLI
[ ] Shareable URLs                      https://ocdn.is/asset/<root> returns content
[ ] Monitoring                          uptime check, LND balance alerts, disk usage
[ ] Backup cron                         schedule scripts/backup.sh every 6h

Exit: public URL serves real content via L402. External client can `dupenet fetch` from anywhere.

## Sprint 9 — Multi-host (prove the network)

Second host connects to the founder's coordinator and mirrors content.
DocRef: MVP_PLAN:§Node Kit (Target: Raspberry Pi), §Bounty Pool Mechanics

[ ] Second VPS (or Pi)                  deploy compose-nodekit.yml pointing at founder coordinator
[ ] Node-agent mirrors content          agent discovers bounty feed, mirrors top CIDs from founder gateway
[ ] Directory shows 2 hosts             GET /directory lists both with pricing + availability
[ ] Spot-checks pass                    coordinator verifies second host has blocks (GET /spot-check)
[ ] Failover works                      kill host 1 → client retries host 2 → content still available
[ ] CLI host selection                  `dupenet fetch` picks cheapest/fastest host from directory
[ ] Receipt flow from second host       L402 fetch from host 2 → receipt → epoch settlement includes both hosts

Exit: two independent hosts serve the same CID. Kill one, content survives. Receipts flow from both.


================================================================================
PATH A.1: EventV1 + REFERENCE MATERIALIZER (no VPS dependency — build while waiting)
================================================================================

Goal: collapse all non-blob, non-receipt protocol actions into EventV1 envelope.
Build reference materializer that interprets kind bytes. Content becomes discoverable,
fundable, and discussable via one endpoint (POST /event) and one query (GET /events).
DocRef: MVP_PLAN:§Protocol vs Materializer Boundary, §Event Layer, §Event Kind Payload Conventions

Architectural decision (2025-02-08):
  - Protocol surface area is the enemy. Proof-of-service is sacred. Everything else is views.
  - EventV1 { v, kind, from, ref, body, sats, ts, sig } is the only non-blob protocol primitive.
  - Protocol rule: if event.sats > 0, credit pool[event.ref] += sats. That's it.
  - Kind interpretation, threading, ranking, author rewards, pin lifecycle, moderation = materializer.
  - Tip / upvote / fortify / pin are all the same action: POST /event with sats > 0.
  - Pins are kind=PIN_POLICY events with drain policy in body. Materializer enforces SLA.
  - Author earnings: not in protocol. Authors self-host (earn as hosts) or earn via materializer bonuses.
  - Existing POST /tip, POST /host/register, POST /content/announce → collapse into POST /event.
  - ReceiptV2 + epoch settlement untouched. Don't fix what's not broken.

## Sprint 7b — EventV1 Envelope (packages/physics)

The protocol-level event primitive. Everything in materializer depends on this.

[ ] EventV1 TypeBox schema             { v: u8, kind: u8, from: bytes32, ref: bytes32, body: bytes, sats: u64, ts: u64, sig }
    - canonical serialization (same pattern as existing schemas)
    - event_id = SHA256(canonical(EventV1 minus sig))
    - Ed25519 signature: sign/verify canonical(EventV1 minus sig)
    - body: inline ≤16 KiB (kind-specific payload)
    - sats: economic weight (0 = free statement, >0 = pool credit)
[ ] Kind byte constants                0x01 FUND, 0x02 ANNOUNCE, 0x03 POST, 0x04 HOST, 0x05 REFUSAL,
                                       0x06 ATTEST, 0x07 LIST, 0x08 PIN_POLICY, 0x09 MATERIALIZER
[ ] Kind payload schemas (TypeBox)     AnnouncePayload, HostPayload, ListPayload, PinPayload
    - these are materializer conventions, not protocol — live under physics for convenience
    - unknown kinds: preserve, don't reject (extensibility)
[ ] Pool credit rule                   if event.sats > 0: credit pool[event.ref] += sats (minus protocol fee)
    - pool_key = event.ref (bytes32 — can be CID, event_id, topic hash)
    - protocol is key-blind; materializer resolves ref → CID for settlement
[ ] EventV1 tests                      construct, sign, verify; pool credit; reject forged/missing sig
[ ] Migrate existing events            TipV1 → kind=FUND, HostServeV1 → kind=HOST, HostRegisterV1 → kind=HOST
    - backward compat: existing POST /tip, POST /host/register still work (shim to POST /event)
    - new canonical path: POST /event (accepts any kind)

Exit: physics exports EventV1. Construct event, sign, verify. Pool rule tested.
      Kind payloads constructable/verifiable. One envelope replaces per-action schemas.

## Sprint 7c — Batch Upload + Content Metadata (apps/cli)

The whistleblower flow: upload a directory of PDFs with human-readable metadata.
All publishing now goes through POST /event with appropriate kind bytes.

[ ] `dupenet upload <dir>`              batch upload: chunk + upload each file in directory
    - recursive traversal, filters by known MIME types
    - progress: file N/M, blocks K/T overall
    - skip already-uploaded blocks (409 Conflict = ok, resume on failure)
    - after upload: POST kind=ANNOUNCE event per file, POST kind=LIST event for collection
[ ] Upload metadata flags               --title, --description, --tags, --language, --source
[ ] Thumbnail generation                generate preview thumbnails client-side (images: 200px JPEG; text: 500 char excerpt)
[ ] `dupenet fund <ref> <sats>`         unified funding command (replaces `dupenet tip`)
    - POST /event with kind=FUND, sats=amount, ref=pool_key
    - works for any ref: CID, event_id, topic hash
    - materializer resolves LIST refs → fan-out across constituents
[ ] `dupenet post <ref> <text>`         publish threaded text (kind=POST)
    - ref = parent event_id (reply) or topic hash (root post)
    - body = inline text ≤16 KiB
    - optional --sats flag to boost own post

Exit: `dupenet upload ~/leak/ --title "Court Filings" --tags epstein,legal`
      → uploads 200 PDFs, publishes ANNOUNCE + LIST events, prints collection URL.
      `dupenet fund <list_event_id> 10000` → credits pool. One endpoint.
      `dupenet post <event_id> "This proves X"` → threaded reply published.

## Sprint 7d — Signal Aggregation + Market Quoting (apps/coordinator — reference materializer)

Materializer views over EventV1 stream. These are product features, not protocol.
All endpoints are materializer conventions — other materializers may offer different views.

[ ] POST /event                         unified event ingest endpoint
    - validate EventV1 sig
    - if sats > 0: credit pool[ref]
    - index by kind, ref, from, ts
    - rate-limit per pubkey/IP (MVP spam defense; paid ingest later)
[ ] GET /events?ref=&kind=&from=&since= generic event query (replaces per-kind GET endpoints)
[ ] Prisma model: Event                 { id, kind, from, ref, body, sats, ts, sig, event_id }
    - indexes: (ref), (kind, ts), (from, ts), (event_id unique)
[ ] GET /feed/recent                    recent ANNOUNCE events (paginated, filterable by tags)
[ ] GET /feed/funded                    pool_keys ranked by balance (replaces GET /bounty/feed)
[ ] GET /host/:pubkey/scorecard         host reputation (from HOST events + spot-checks + receipts)
[ ] GET /content/:ref/signals           content resilience (from FUND events + receipts + HOST events)
[ ] GET /author/:pubkey/profile         pseudonymous reputation (events by pubkey + demand on their content)
[ ] GET /market/quote                   supply curve from host min_bounty_sats thresholds
[ ] GET /thread/:event_id               thread view: resolve ref chain from kind=POST events, return tree

Exit: POST /event accepts all kinds. GET /events returns filtered stream.
      GET /feed/funded ranks by pool balance. GET /thread/<id> returns discussion tree.
      Signal endpoints are materializer views — not protocol.

## Sprint 7d.1 — Event Log Compaction + Snapshot Bootstrap (packages/physics + apps/coordinator)

Unchanged in scope. Snapshots now cover pools (keyed by ref) instead of bounty pools (keyed by CID).
DocRef: MVP_PLAN:§Event Log Growth + Compaction, §Longevity L7

[ ] StateSnapshotV1 schema             physics: epoch, merkle roots for pools / hosts / events / serves, event_count, prev_hash
[ ] Merkle tree library                physics: build from sorted key-value pairs, generate/verify inclusion proofs
[ ] Snapshot generator                 coordinator: materialize Prisma state into StateSnapshotV1
[ ] GET /snapshot/latest, GET /snapshot/:epoch, GET /snapshot/:epoch/proof/:key
[ ] Receipt rollup in epoch settlement EpochSummary stores receipt merkle_root + counts only
[ ] GET /bootstrap                     fast node sync: latest snapshot + events since
[ ] Snapshot verification              publisher sig (MVP), Bitcoin-anchored epoch root (L7)
[ ] Snapshot + inclusion proof tests

Exit: GET /bootstrap returns snapshot + recent events. New node materializes in seconds.

## Sprint 7e — Web Content Surface + Threading

The page that makes content visible, fundable, and debatable. Recipients see content,
resilience signals, a Fund button, and threaded discussion. This IS the product.

[ ] Scaffold web app                   apps/web, Next.js, server-renders from materializer APIs
[ ] Content landing page: /v/<ref>     single asset view
    - header: title, description (from kind=ANNOUNCE events), kind, mime, size
    - preview: thumbnail or text excerpt
    - instrument cluster: pool balance, replica count, epoch survival, demand trend
    - Fund button: amount slider → POST /event kind=FUND (one action, all amounts)
[ ] Collection page: /c/<event_id>     grouped content view (from kind=LIST events)
    - item list with per-asset signals + aggregate resilience
    - Fund button: fan-out across constituents (materializer resolves)
[ ] Thread page: /t/<event_id>         threaded discussion view
    - renders kind=POST event ref chains as tree
    - per-post: sats committed, unique funders, author age
    - reply box: POST kind=POST with ref=parent_event_id (PoW for free; optional sats to boost)
[ ] Market quote display               "Add X sats → est. Y copies for Z days" from supply curve
[ ] Lightning payment (browser)        Fund button → WebLN auto-pay + QR fallback → POST /event
[ ] Free preview serving               gateway serves thumb CIDs / small blocks without L402
[ ] Host scorecard page: /h/<pubkey>   host reputation view from scorecard endpoint

Exit: share https://ocdn.is/v/<ref> → content + signals + Fund button.
      /t/<event_id> → monetized threaded discussion. Flame wars cost sats, not words.
      One Lightning payment via one endpoint. One action: fund.


================================================================================
PATH B: S3 ADAPTER (platform adoption)
================================================================================

Goal: existing apps switch to dupenet storage with a config change.
DocRef: MVP_PLAN:§S3-Compatible Adapter (Layer A — Migration Unlock)

## Sprint 10 — S3-compatible adapter (apps/s3-adapter)

Thin shim that speaks S3 protocol and translates to the blob layer.
Single-tenant: runs alongside the consuming app, talks to one gateway.

[ ] Project scaffold                    apps/s3-adapter, TypeScript + Fastify (or http)
[ ] Auth layer                          S3 access key → protocol pubkey mapping (thin translation)
    - single-user mode for MVP (one access key)
    - SigV4 signature verification (just enough to satisfy AWS SDKs)
[ ] PUT object → chunk + upload         receive S3 PutObject → chunk file → PUT /block × N → PUT /file → PUT /asset
    - compute asset_root, return as ETag
    - handle multipart uploads (S3 multipart → map to block uploads)
    - chunking reuses @dupenet/physics
[ ] GET object → resolve + stream       S3 GetObject → GET /asset → GET /file → stream GET /block × N
    - reassemble blocks into response stream
    - Range header support (partial reads)
    - Content-Type from AssetRoot mime
[ ] HEAD object                         S3 HeadObject → HEAD /asset → return size, content-type, ETag
[ ] DELETE object                       return 204 (no-op; content-addressed = no true delete)
[ ] LIST objects                        return list of known asset_roots (local cache)
    - or: return empty (many apps don't need LIST)
[ ] Bucket abstraction                  all objects in one "bucket" (single gateway = single bucket)
[ ] Integration test                    `aws s3 cp` in, `aws s3 cp` out, `aws s3 ls` → identical bytes
[ ] Docker image                        add to compose-founder.yml as optional service

Exit: `aws s3 cp file.tar s3://dupenet/file.tar` succeeds.
      `aws s3 cp s3://dupenet/file.tar -` returns identical bytes.
      No code changes in the consuming app.

## Sprint 11 — SDK + documentation

Make Layer A consumable by external developers.
DocRef: MVP_PLAN:§Receipt Verification SDK, §Adoption Path

[ ] receipt-sdk published               npm publish @dupenet/receipt-sdk (zero deps, works everywhere)
[ ] physics published                   npm publish @dupenet/physics (or subset: canonical, cid, chunker)
[ ] HTTP API reference                  OpenAPI/Swagger spec for gateway + coordinator endpoints
    - generated from route definitions or hand-written
    - hosted at docs.dupenet.dev
[ ] Integration guide                   "Store files on dupenet in 5 minutes"
    - code samples: upload, fetch, tip, pin
    - S3 adapter setup guide
[ ] Receipt verification guide          "Verify paid consumption in your app"
    - import receipt-sdk → verify receipts → rank content / gate access
    - cross-platform use cases (Nostr, forums, media apps)
[ ] Pin contract guide                  "Pay for durability"
    - create pin, monitor copies, cancel/refund flow

Exit: a developer who has never seen the codebase can integrate in <1 hour.


================================================================================
REMAINING POLISH (non-blocking, do when convenient)
================================================================================

[ ] EXIF/metadata stripping             strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation           TypeBox schemas defined but Value.Check not called on ingest
[ ] Stake locking via LND               verify stake payment on host registration (currently stubbed)
[ ] Deterministic Docker builds         Nix flake or pinned multi-stage (DocRef: MVP_PLAN:§Longevity L6)
[ ] Epoch root anchoring                Bitcoin tx per epoch: SHA256(epoch_summary_root || snapshot_hash) (DocRef: MVP_PLAN:§Longevity L7)
    - makes state snapshots trustlessly verifiable (no need to trust coordinator)
    - depends on Sprint 7d.1 (snapshot format must exist first)
    - Taproot tweak or OP_RETURN, ~$0.50/day at 1 tx/day covering 6 epochs

External review fixes (solved — applied to mvp_plan.md):
[x] FileManifest merkle_root            real binary Merkle tree (leaf hash + pair hash), not SHA256(concat) (#1)
    - enables inclusion proofs, streaming verification, partial block validation
[x] Stake language: custodial            "deposited with coordinator — custodial in MVP" (#4)
    - post-MVP: on-chain UTXO, federation, or DLC-based escrow
[x] Free preview rate limiting           per-IP token bucket (60 burst / 10 sustained); CDN for founder hosts (#6)
    - hosts can disable free tier; MUST rate-limit if enabled
[x] Storage pricing knob                 sats_per_gb_month: u64? added to PricingV1 (#8)
    - enables durability estimation: (bounty - egress_drain) / (storage_cost * size_gb) = months
[x] Pin SLA semantics                    best effort + full refund if min_copies unmet 6 epochs (#10)
    - no PIN_CANCEL_FEE on SLA-triggered cancel; regions relaxable via signed amendment


================================================================================
POST-MVP ASSESSMENT (deferred from external review, assess after launch)
================================================================================

DocRef: MVP_PLAN:§Post-MVP Assessment Queue

[ ] Event spam pricing                 decide: paid ingest (402-gated POST /event) vs rate-limited + PoW
    - MVP: materializer rate-limits per pubkey/IP (sufficient at founder scale)
    - POST kind=POST (threaded comments) especially needs friction: PoW min, optional sats
    - assess once real event volume + abuse patterns visible
    - paid ingest funds materializers (product toll, not protocol toll)
    - PoW per event acceptable for humans; evaluate impact on automated publishers

[ ] min_bounty_sats quote gaming       compute behavioral thresholds from HostServe event data
    - MVP: founder knows all hosts, gaming irrelevant
    - post-MVP: observed_threshold = min bounty at which host first served a CID
    - show confidence intervals (self-reported vs observed) when data sufficient
    - separately evaluate slashable signed quotes (expands slash surface beyond crypto fraud)
    - trigger: host count > 50 and supply curve UI is live

[ ] Multi-source parallel download     client fetches blocks from multiple hosts simultaneously
    - MVP: single-host fetch with failover (sufficient for 2-3 hosts)
    - protocol already supports it (block-level addressing + multiple hosts per CID)
    - deferred: partial-file payment economics, block availability bitmap, stripe strategy
    - trigger: 3+ hosts serve the same CID in production

[ ] Receipt privacy (ephemeral pubkeys) clients SHOULD use one-time keypairs for receipt submission (#5)
    - receipt submission already opt-in; casual readers (L402 only) have no protocol exposure
    - ephemeral pubkeys don't weaken anti-sybil: hard defense is economic (L402 cost + mint token),
      not identity-based (key generation is free; PoW escalation per-pubkey already trivially bypassed)
    - RECEIPT_MIN_UNIQUE=3 is a tripwire, not a wall (3 throwaway keys cost zero)
    - lean on payment-based diversity signals: distinct payment_hash, temporal spread, graph breadth
    - aggregator remains MVP privacy trust point (same as all founder dependencies)
    - long-term: blinded/bearer receipts (Cashu-style) for zero-knowledge demand proofs
    - spec updated: MVP_PLAN:§Receipt Privacy (DocRef: MVP_PLAN:§Fetch Flow, §Host Self-Farming)

[ ] Audit griefing hardening            cap frequency, deterministic target selection (#9)
    - cap audit frequency per (host, cid, epoch) — prevents bandwidth griefing
    - PRF-based audit target selection (auditable but unpredictable to host)
    - L402 cost already gates spam audits; separate auditor bond adds complexity, defer
    - regional selective failure (honest to auditor IPs, corrupt to others): operational fix (Tor), not protocol fix
    - trigger: audit volume becomes meaningful (>100 audits/day)

[ ] Client safety layer                 layered pre/post-fetch safety, no sandboxing (#11)
    - mirrors operator attestation model (§Operator Content Policy) applied to client side
    - pre-fetch: MIME-type gate (warn on executables/scripts), publisher signal display, CID denylist
    - post-fetch: SHA256 verify (already in spec), magic bytes vs declared MIME, known-good list check
    - ClientPolicyV1 schema: attester_follow, mime_warn, mime_block, trusted_publishers, threshold
      same import/export format as operator policy JSON
    - known-good lists = signed kind=LIST events from projects (code signing via CIDs)
    - encrypted blobs opaque to attesters — packs only work for known-flagged unencrypted CIDs
    - out of scope: OS-level sandboxing, content rating, server-side scanning, global blocklist
    - applied to mvp_plan.md: new §Client Safety Layer section
    - trigger: first malware incident in production

[~] Materializer market + paid ingest   materializers = metadata hosts, same L402 economics (#12 + A)
    - key insight: materializer is a host for metadata — ingest events (POST /event),
      serve queries (GET /events, GET /feed, GET /thread). Same L402, same market.
    - EventV1 envelope + kind bytes formalized (2025-02-08 architectural decision)
    - kind=MATERIALIZER event for discovery; MaterializerPayload in kind conventions
    - MVP: founder is sole materializer; free ingest (rate-limited), free queries
    - author rewards = materializer product feature (rebate/bonus from materializer fees), NOT protocol
    - remaining design work (post-MVP, trigger: second materializer operator):
      - relay-vs-materializer economic separation at scale
      - consistency model for divergent materializer state
      - economic tuning: ingest fee vs query fee balance

[ ] Founder service replacement specs   inputs/outputs/swap procedure per service (B)
    - for each: directory, mints, aggregator, snapshots, provisioning, materializer
    - test: can a stranger replace it without "contact the founder"?
    - if not, the longevity section should say so honestly
    - trigger: pre-launch documentation pass


LEGEND: [x] done  [~] partial/stub  [ ] not started
