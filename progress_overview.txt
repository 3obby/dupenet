dupenet MVP ‚Äî Progress Overview
================================

PHASE 1: BLOB UTILITY (Layer A)
--------------------------------

## Step 1 ‚Äî File Layer + Gateway + HTTP Origin

[x] Canonical serialization          deterministic CBOR, sorted keys (packages/physics)
[x] CID computation                  SHA256-based content addressing
[x] Chunker                          256KiB blocks, reassembly
[x] Merkle tree                      binary merkle, odd-leaf promotion
[x] FileManifestV1 schema            TypeBox schema (chunk_size, size, blocks[], merkle_root)
[x] AssetRootV1 schema               TypeBox schema (kind, original, variants, meta)
[x] PricingV1 schema                 min_request_sats, sats_per_gb, burst
[x] Block storage backend            filesystem: {base}/{h[0:2]}/{h[2:4]}/{hash}
[x] PUT /block/:cid                  SHA256 verified on receive, rejects mismatches
[x] GET /block/:cid                  serves bytes; L402-gated when LND configured, free in dev mode
[x] PUT /file/:root                  validates file_root = SHA256(canonical(manifest)), checks all blocks exist
[x] GET /file/:root                  returns manifest (in-memory Map)
[x] PUT /asset/:root                 validates asset_root = SHA256(canonical(AssetRoot)), checks file exists
[x] GET /asset/:root                 returns asset (in-memory Map)
[x] HEAD /asset/:root                returns size, kind, mime headers
[x] GET /pricing                     returns PricingV1
[x] GET /health                      gateway health check
[x] Physics unit tests               canonical, cid, chunker, merkle, reward, epoch-aggregation, availability, block-selection, event-signature (9 suites, vitest)
[x] Gateway integration test          PUT /block xN -> PUT /file -> PUT /asset -> GET -> reassemble -> verify (7 tests)
[ ] EXIF/metadata stripping           strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation         TypeBox schemas defined but Value.Check not called on ingest

## Step 2 ‚Äî L402 Paid Fetch + Receipt Minting

[x] Mint service structure            POST /sign, GET /pubkey, GET /health (apps/mint)
[x] Ed25519 keypair load              loads from MINT_PRIVATE_KEY_HEX env var
[x] Receipt token format              Sign("R2" || host || epoch || block_cid || response_hash || price || payment_hash)
[x] LND service in docker compose     lnd v0.18.5-beta + bitcoind regtest, 2-node (alice+bob) in compose-founder.yml
[x] LND config fields                 LND_HOST, LND_MACAROON_PATH, LND_TLS_CERT_PATH in gateway + mint config
[x] LND client package                packages/lnd-client: LndClient interface, REST impl, MockLndClient for tests
[x] L402 challenge-response           GET /block returns 402 + invoice -> pay with preimage -> bytes + receipt_token
[x] Invoice store                     in-memory TTL map (payment_hash -> {cid, price, host, epoch, expiry})
[x] Invoice generation                gateway creates invoice via LndClient.createInvoice()
[x] Mint settlement check             mint calls LndClient.lookupInvoice(), verifies SETTLED + amount >= price
[x] Mint HTTP client                  gateway calls POST /sign on mint, receives receipt_token
[x] min_request_sats enforcement      price = min_request_sats used for all block fetches
[x] L402 integration tests            8 tests: 402 challenge, paid fetch, invalid/unknown/mismatch/single-use (mock LND)
[x] Client PoW receipt minting        minePoW(), buildChallengeRaw/ClientSigPayload/TokenPayload in physics
[x] Block selection (anti-special)    selectBlockIndex(), selectBlock(), verifyBlockSelection() in physics (SHA256 PRF)

## Step 3 ‚Äî Node Kit + Host Registration

[x] compose-founder.yml               gateway, mint, coordinator, postgres, lnd, caddy (all with healthchecks)
[x] compose-nodekit.yml               gateway, node-agent, caddy
[x] Coordinator structure             Hono server with routes, event log, materialized views
[x] POST /host/register               registers host (stub stake verification)
[x] GET /directory                     returns host list from in-memory Map
[x] Node-agent poll loop                discover profitable CIDs ‚Üí mirror from source ‚Üí announce serve (complete)
[x] Mirror agent                       findProfitableTargets() queries GET /bounty/feed; mirrorCid() fetches + pushes
[x] Directory announcement             announceHost() signed registration; announceServe() signed HostServe
[x] Availability score tracking        computeAvailabilityScore() in physics + updateAllScores() in coordinator
[x] Status lifecycle                   PENDING->TRUSTED (score>=0.6), TRUSTED->DEGRADED (score<0.6), ->INACTIVE (score==0)
[x] Spot-check responder              GET /spot-check/:cid on gateway (verifies hash, no L402, no bytes)
[x] Spot-check runner                 spotCheckHost(), runAllChecks() in coordinator (injectable fetcher)
[x] SpotCheck Prisma model            hostPubkey, cid, epoch, passed, latencyMs, error
[x] POST /hosts/check                 triggers spot-checks for all active hosts, updates scores
[x] GET /hosts/:pubkey/checks         returns check history + availability score + recommended status
[x] Availability tests                9 physics + 12 coordinator tests (scoring, transitions, spot-check runner)
[ ] Stake locking via LND              TODO: verify stake payment
[x] CID selection agent                queries GET /bounty/feed, filters by minBounty, mirrors top profitability CIDs

## Step 4 ‚Äî Receipt Verification SDK

[x] VerifyReceiptV2 function           packages/receipt-sdk, full verification logic
[x] Ed25519 verify                     Web Crypto API, zero dependencies
[x] PoW hash check                     H(challenge || nonce) < TARGET validation
[x] Client signature check             Ed25519 sig over receipt payload
[x] Zero external dependencies         only crypto.subtle
[x] Test vectors                       valid e2e receipt (construct -> verify), invalid hex/PoW/token, wrong mint key (7 tests)

## Step 5 ‚Äî Pin Contracts

[x] PinContractV1 schema               TypeBox schema (physics) + Prisma model
[x] POST /pin                           creates pin, computes drain_rate, credits bounty pool, logs event
[x] GET /pin/:id                        returns status, remaining budget, active hosts, copies_met, epoch proofs
[x] POST /pin/:id/cancel               returns remaining budget minus 5% fee, status -> CANCELLED
[x] Drain rate enforcement              drainPinBudgets() deducts min(actualDrain, drainRate) per epoch
[x] Budget management                   creditBountyDirect (no protocol fee); debitPayout on cancel refund
[x] Lifecycle transitions               ACTIVE -> EXHAUSTED (when remainingBudget=0); ACTIVE -> CANCELLED (on cancel)
[x] min_copies check                    getPinStatus compares active hosts vs min_copies, returns copies_met
[x] Epoch proof bundle                  getPinStatus returns recent EpochSummaryRecords for pinned asset (last 6 epochs)
[x] Pin contract tests                  22 tests: validation, create, status, cancel, drain rate, exhaustion
[x] Pin ID deterministic                SHA256(canonical(pin content)) ‚Äî duplicate detection via unique constraint

COORDINATOR ‚Äî PERSISTENCE + AGGREGATION
-----------------------------------------

[x] Prisma schema                      Event, BountyPool, Host, HostServe, EpochSummaryRecord, PinContract
[x] Prisma client generated            in Dockerfile (npx prisma generate)
[x] POST /tip                          credits bounty pool (in-memory Map, stub sig verification)
[x] GET /bounty/:cid                   reads from in-memory Map
[x] Event log writer                   in-memory array (not persisted)
[x] Bounty pool view                   in-memory Map
[x] Host registry view                 in-memory Map
[x] Epoch math                         packages/physics: epoch length 4h, current epoch, epoch boundaries
[x] Reward formulas                    cidEpochCap, computeHostScore, distributeRewards (physics)
[x] EpochSummary schema                defined in physics
[x] Coordinator -> Postgres             bounty-pool, host-registry, event-log all use PrismaClient (tsc clean)
[x] Event log persistence               append-only Postgres via prisma.event.create
[x] POST /receipt/submit                validates via receipt-sdk, checks epoch range + replay, stores in Prisma
[x] Receipt validation pipeline         verifyReceiptV2 checks client_sig, PoW, receipt_token against mint pubkeys
[x] Epoch aggregation (physics)         aggregateReceipts(), isPayoutEligible() ‚Äî pure receipt grouping + 5/3 threshold
[x] Epoch settlement (coordinator)      settleEpoch() ‚Äî aggregate receipts, compute payouts, drain bounty, persist EpochSummary
[x] POST /epoch/settle                  validates epoch is closed, calls settleEpoch(), idempotent (no double-spend)
[x] GET /epoch/summary/:epoch           returns settlement results for a given epoch
[x] Payout execution                    distributeRewards() called by settleEpoch(), rewards split by host score
[x] Bounty drain                        cidEpochCap() limits per-epoch drain, debitPayout() debits pool
[x] Aggregator fee                      3% deducted from cap before host distribution
[x] Epoch settlement tests              8 coordinator tests (mock Prisma) + 12 physics aggregation tests
[x] Epoch boundary trigger              createEpochScheduler() auto-settles closed epochs; configurable interval + spot-checks
[x] Signature verification on events    Ed25519 verify on POST /tip and POST /host/register; rejects forged/missing sigs

DOCKER / DEPLOY
-----------------

[x] compose-founder.yml                bitcoind + lnd-alice + lnd-bob + gateway + mint + coordinator + postgres + caddy
[x] compose-nodekit.yml                gateway + node-agent + caddy (separate Caddyfile)
[x] Dockerfiles (4 apps)               multi-stage node:20-alpine builds (gateway, mint, coordinator, node-agent)
[x] Coordinator entrypoint             prisma db push --skip-generate on startup (idempotent)
[x] LND credential sharing             lnd-data volume mounted read-only to gateway + mint
[x] LND REST wiring                    gateway + mint create LndRestClient when macaroon exists (dev mode fallback)
[x] @noble/ed25519 sha512 setup        mint signer configures sha512Sync from @noble/hashes
[x] Caddyfile.founder                  gateway + coordinator routes (/spot-check, /epoch, /hosts added)
[x] Caddyfile.nodekit                  gateway-only routes
[x] scripts/gen-keys.sh                generates Ed25519 keypairs (host + 3 mints), writes .env.local
[x] scripts/fund-lnd.sh                funds alice + bob, opens 1M sat channel
[x] scripts/e2e.sh                     E2E test skeleton (needs polish for receipt/settle path)
[x] Startup config echo                all 4 apps print config on boot (port, LND mode, mint keys, genesis)
[x] GENESIS_TIMESTAMP_MS env var       coordinator + gateway; enables epoch boundary control for testing
[x] @types/node for Docker builds      physics + receipt-sdk; fixes Web Crypto type errors in Docker context
[x] Buffer.slice() fix (ed25519)       wcBuf() helper handles cbor-x Buffer views correctly

INTEGRATION / E2E
------------------

[x] Gateway round-trip test             upload multi-block file, retrieve by asset_root, verify SHA256 (7 tests)
[x] L402 flow test                      402 -> pay invoice -> receive block + receipt_token (8 tests, mock LND)
[x] Docker E2E                          FULL PASS: upload ‚Üí 402 ‚Üí bob pays ‚Üí block + receipt_token ‚Üí tip ‚Üí receipt submit ‚Üí epoch settle ‚úì
[x] Receipt round-trip test             construct valid receipt (PoW + mint sig + client sig) -> verifyReceiptV2 passes
[x] Epoch settlement test              mock Prisma: eligible/ineligible hosts, bounty drain, idempotency, score split
[x] Pin contract test                  mock Prisma: create/status/cancel, drain rate, exhaustion, validation (22 tests)
[x] Availability test                  mock Prisma + mock fetcher: spot-check, scoring, transitions (12 tests)
[x] Event signature test               real Ed25519 keypairs: signed tip/register accepted, forged/missing rejected (7 tests)
[x] Bounty feed + host/serve test     bounty feed returns profitable CIDs; signed serve announcements (6 tests)
[x] Node-agent poll cycle test        mock fetch: discover, mirror, error handling (6 tests)
[x] Epoch scheduler test             mock Prisma: tick settles, idempotent, start/stop, error handling (7 tests)

SPRINT ORDER (Phase 1 ‚Äî complete)
-----------------------------------

1. Gateway integration tests            DONE (7 tests pass)
2. L402 + mint settlement               DONE (8 tests pass, mock LND; Docker E2E with real LND in sprint 6)
3. Coordinator -> Postgres              DONE (tsc clean; requires `prisma db push` + Postgres to run)
4a. Receipt submission + validation     DONE (receipt-sdk e2e test passes; coordinator handler typechecks)
4b. Epoch aggregation + payout          DONE (20 new tests: 12 physics + 8 coordinator; bounty drains correctly)
5. Pin contracts lifecycle              DONE (22 new tests; create, cancel, drain rate, exhaustion all work)
6. Docker E2E                           DONE ‚Äî full pipeline: upload ‚Üí L402 paid fetch ‚Üí tip ‚Üí receipt submit ‚Üí epoch settle


================================================================================
DIVERGENCES (code vs mvp_plan.md ‚Äî fix before or during Sprint 7b)
================================================================================

Audit date: 2026-02-09. Cross-referenced all completed code against MVP plan spec.

## Fee Model ‚Äî FIXED

[x] Volume-tapering founder royalty     replaced flat 5% (TIP_PROTOCOL_FEE_PCT) with r(v) formula
    - packages/physics/src/royalty.ts: founderRoyaltyRate(), computeRoyalty(), cumulativeFounderIncome()
    - apps/coordinator/src/views/bounty-pool.ts: creditTip() now queries cumulative volume, applies formula
    - constants.ts: FOUNDER_ROYALTY_R0=0.15, V_STAR=125M, ALPHA=log(2)/log(9)
    - removed: TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
    - 170/170 tests pass

## Pool Key (blocks event/topic funding)

## Pool Key (blocks event/topic funding) ‚Äî FIXED

[x] BountyPool keyed by generic bytes32
    - Prisma BountyPool.poolKey: String @id @map("cid") ‚Äî no DB migration needed
    - All routes, views, tests updated to use poolKey
    - Accepts CID, event_id, or topic hash

## Gateway Endpoints ‚Äî FIXED

[x] GET /cid/{hash} unified endpoint
    - apps/gateway/src/routes/cid.ts: if asset ‚Üí 302 /asset/; if file ‚Üí 302 /file/; if block ‚Üí serve bytes

[x] Free preview tier
    - blocks ‚â§ FREE_PREVIEW_MAX_BYTES (16 KiB) served without L402
    - configurable: FREE_PREVIEW_ENABLED env var (default true)
    - per-IP rate limiting deferred (sufficient for founder scale)

## PricingV1 Schema ‚Äî FIXED

[x] PricingV1 now has all 6 fields   burst_sats_per_gb, min_bounty_sats, sats_per_gb_month, open_min_pool_sats
    - packages/physics/src/schemas/host.ts: 4 new Optional() fields added
    - all backward-compatible (existing 2-field PricingV1 still valid)

## Constants ‚Äî MOSTLY FIXED

[x] Stale constants removed            TIP_PROTOCOL_FEE_PCT, PROTOCOL_FEE_HALVING_YEARS, PROTOCOL_FEE_SUNSET_YEARS
[x] Royalty constants added             FOUNDER_ROYALTY_R0, V_STAR, ALPHA
[x] PricingV1 constants added          BURST_SATS_PER_GB, MIN_BOUNTY_SATS_DEFAULT, OPEN_MIN_POOL_SATS_DEFAULT
[x] Event constants added              EVENT_POW_TARGET, EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES
[x] AGGREGATOR_FEE_PCT added to plan   MVP default (3%), market-determined post-MVP

Plan constants still missing from code (add during relevant sprint):
    - BASE_FEE = 21-210 sats                  ‚Üí Sprint 7b (EventV1 ingest, dynamic pricing)
    - SNAPSHOT_INTERVAL_EPOCHS = 100          ‚Üí Sprint 7d.1
    - ANCHOR_INTERVAL_EPOCHS = 6             ‚Üí Sprint 7d.1
    - PREVIEW_THUMB_WIDTH = 200              ‚Üí Sprint 7e
    - PREVIEW_TEXT_CHARS = 500               ‚Üí Sprint 7e

## Schema Gaps (non-blocking, fix during relevant sprint)

[ ] EpochSummary missing receipt_merkle_root    ‚Üí Sprint 7d.1 (snapshot/compaction)
[ ] DirectoryV1 missing regions[], refusals_cid, materializers[]  ‚Üí Sprint 7b
[ ] No MaterializerV1 / MaterializerPricingV1 schema  ‚Üí Sprint 7b
[x] EventV1 TypeBox schema                       DONE ‚Äî packages/physics/src/schemas/event.ts
[ ] Pin cancel: no SLA-triggered fee waiver    ‚Üí Sprint 7b (needs SLA monitoring)
[ ] GET /served endpoint missing               ‚Üí Sprint 7b (low priority)
[x] Node-agent publishes min_bounty_sats       DONE ‚Äî announce.ts includes full PricingV1

## False Positive in Progress Log ‚Äî FIXED

[x] sats_per_gb_month now in TypeBox schema (host.ts) as Optional field. Progress log corrected.

## Codebase Review Fixes (2026-02-09)

[x] Bug: INACTIVE‚ÜíTRUSTED transition   host-registry.ts ‚Äî INACTIVE hosts that recover now transition back
[x] Bug: mirror multi-block assets     node-agent/mirror.ts ‚Äî resolves AssetRoot‚ÜíManifest‚Üíblocks (was single-block only)
[x] Bug: mint input validation         mint/server.ts ‚Äî POST /sign now validates all 6 fields (was crashing on undefined)
[x] Bug: invoice store leak            gateway/server.ts ‚Äî cleanup() now called every 60s via setInterval + onClose hook
[x] Dead code: satsPerGb passthrough   gateway/routes/block.ts ‚Äî removed from BlockRouteContext (flat minRequestSats is correct)
[x] Test: royalty.ts coverage          16 new tests: formula at plan anchor points, monotonicity, edge cases, input guards
[x] Test: availability transition      fixed test expectation: score=0 ‚Üí INACTIVE (not DEGRADED) per plan lifecycle
    Total after review fixes: 186/186 tests pass (was 170)

## Sprint 7b Implementation (2026-02-09)

[x] EventV1 schema + sign/verify      packages/physics: EventV1 TypeBox, event-v1.ts (sign, verify, eventId, body encode/decode)
[x] Kind constants + payloads         9 kind bytes (FUND..MATERIALIZER) + AnnouncePayload, HostPayload, ListPayload, PinPayload
[x] POST /event endpoint              coordinator: unified event ingest, sig verify, pool credit, kind=HOST side effect
[x] Pool key generalization           Prisma BountyPool.poolKey (@map("cid")), all views + tests updated
[x] GET /cid/:hash endpoint           gateway: unified resolve (asset‚Üí302, file‚Üí302, block‚Üíserve)
[x] Free preview tier                 gateway: blocks ‚â§16 KiB served without L402 (configurable)
[x] Node-agent min_bounty_sats       announce.ts: publishes full PricingV1 with min_bounty_sats + open_min_pool_sats
[x] 24 new EventV1 tests             event-v1.test.ts: construct, sign, verify, event_id, body, kind constants, lifecycle
    Total after Sprint 7b: 203/203 tests pass (was 186)

## Sprint 7d Implementation (2026-02-09)

[x] ProtocolEvent Prisma model        indexed materializer view: event_id (unique), (ref), (kind,ts), (from,ts)
[x] POST /event ‚Üí ProtocolEvent       events now stored in both generic log + indexed ProtocolEvent table
[x] GET /events query                  generic event query: filter by ref, kind, from, since; paginated
[x] GET /feed/funded                   pool keys ranked by balance + ANNOUNCE metadata from ProtocolEvent
[x] GET /feed/recent                   recent ANNOUNCE events, decoded metadata, tag filter, pagination
[x] GET /thread/:event_id             recursive ref-chain resolution into tree (depth-limited)
[x] materializer.ts view module       storeProtocolEvent, queryEvents, feedFunded, feedRecent, getThread
[x] 18 new materializer tests         materializer.test.ts: POST‚Üístore, events query, funded/recent feeds, thread tree
    Total after Sprint 7d: 221/221 tests pass (was 203)

## Sprint 7e Implementation (2026-02-09)

[x] Next.js 15 scaffold               apps/web: App Router, server components, no client JS
    - package.json, tsconfig.json, next.config.js, globals.css
    - craigslist aesthetic: monospace, no styling, symbols/numbers only
[x] API client                        src/lib/api.ts: all coordinator fetches + formatting helpers
[x] / Leaderboard                     table: #, sat, hosts, title, proof ‚Äî from GET /feed/funded
[x] /v/[ref] Content                  metadata + stats + thread ‚Äî from GET /events + /bounty + /thread
[x] /c/[ref] Collection               list items with per-item pool balances ‚Äî from GET /events + /bounty
[x] /p/[ref] Proof                    hash, pool, hosts, epoch proofs ‚Äî from /bounty + /directory + /epoch/summary
    Total: 228/228 tests pass + Next.js build clean (4 pages + 3 API routes, server + client components)

## Sprint 7c Implementation (2026-02-09)

[x] dupenet fund <ref> <sats>         apps/cli/src/commands/fund.ts ‚Äî POST /event kind=FUND
[x] dupenet post <ref> <text>         apps/cli/src/commands/post.ts ‚Äî POST /event kind=POST, --sats flag
[x] dupenet upload + ANNOUNCE         upload.ts now emits ANNOUNCE event with --title/--tags/--access
    Total: 221/221 tests pass + CLI tsc clean + Next.js build clean


================================================================================
PATH A: DEPLOY + CLI (get content flowing)
================================================================================

Goal: founder can upload seed content, share links, people can fetch via L402.
DocRef: MVP_PLAN:¬ßBootstrap Sequence (Week 1-2), ¬ßWhat Layer A Markets Need

## Sprint 7 ‚Äî CLI client (apps/cli)

The minimum tool for a human to use the protocol without curl.
Wraps the HTTP API into a command-line workflow.

[x] Project scaffold                    apps/cli, TypeScript, imports @dupenet/physics, commander
[x] `dupenet upload <file>`             chunk ‚Üí PUT /block √ó N ‚Üí PUT /file ‚Üí PUT /asset ‚Üí print asset_root
    - chunker + manifest + asset root construction (reuse physics)
    - multi-block upload with progress indicator
    - MIME auto-detect from extension, auto kind (TEXT/IMAGE/AUDIO/VIDEO/FILE)
    - print shareable URL: https://<gateway>/asset/<root>
[x] `dupenet fetch <cid> [-o file]`     GET /asset ‚Üí GET /file ‚Üí stream GET /block √ó N ‚Üí reassemble ‚Üí write
    - auto-detect: raw CID (single block) vs asset_root (multi-block)
    - L402 flow: get 402 ‚Üí pay invoice via LND REST ‚Üí present preimage ‚Üí receive bytes
    - --free flag fails instead of paying (for dev mode gateways)
    - SHA256 integrity verification on reassembly
[x] `dupenet tip <cid> <sats>`          sign tip ‚Üí POST /tip ‚Üí print bounty balance
    - Ed25519 sign from local keyfile (~/.dupenet/key.json)
    - print pool_credit + protocol_fee
[x] `dupenet pin create <asset_root>`   POST /pin ‚Üí print pin_id, drain_rate
    - --budget, --duration, --copies flags
    - `dupenet pin status <pin_id>` ‚Üí GET /pin/:id
    - `dupenet pin cancel <pin_id>` ‚Üí POST /pin/:id/cancel
[x] `dupenet info <cid>`                GET /bounty/:cid + GET /asset/:root ‚Üí print summary
    - bounty balance, asset metadata, gateway pricing
[x] `dupenet keygen`                    generate Ed25519 keypair ‚Üí write to ~/.dupenet/key.json
    - reuse physics generateKeypair()
    - --force to overwrite existing
    - print pubkey hex
[x] `dupenet config`                    gateway URL, coordinator URL, key path, LND connection
    - ~/.dupenet/config.json
    - env var overrides (DUPENET_GATEWAY, DUPENET_COORDINATOR, DUPENET_KEY_PATH)
[x] `dupenet hosts`                     GET /directory ‚Üí print host list + pricing + status
[x] LND payment integration             pay L402 invoices via LND REST (/v2/router/send)
    - connect to user's LND (REST, macaroon auth)
    - fallback: print invoice + prompt for manual wallet payment

Exit: `dupenet upload cat.jpg` ‚Üí prints asset_root URL ‚Üí `dupenet fetch <root> -o out.jpg` ‚Üí identical file.
      `dupenet tip <root> 100` ‚Üí bounty pool credited.

## Sprint 8 ‚Äî Real deployment (founder stack on VPS)

The founder stack moves from Docker-on-laptop to a public server.
DocRef: MVP_PLAN:¬ßNode Kit, ¬ßWhat Hosts vs What You Host, ¬ßBootstrap Sequence, ¬ßInfrastructure Partners

[x] VPS provisioning                    FlokiNET Romania (4 CPU, 4GB RAM, 90GB NVMe, 9TB BW, DDoS prot.)
[x] Domain acquired                     ocdn.is (ISNIC Iceland ‚Äî ccTLD, seizure-proof, WHOIS privacy)
[~] DNS A record                        ocdn.is ‚Üí 185.165.169.8 (pending ISNIC activation)
[x] compose-production.yml              signet LND, hardened Postgres, restart policies, no regtest services
[x] Caddyfile.production                ocdn.is domain, automatic HTTPS via Caddy/Let's Encrypt
[x] scripts/deploy.sh                   one-shot server setup (Docker, git, keys, firewall)
[x] scripts/backup.sh                   Postgres dump + LND SCB, 14-day retention, cron-ready
[x] .env.example updated                production DB creds, signet macaroon paths, ocdn.is endpoint
[ ] Server access                       VPS provisioned, awaiting Proxmox lock clear (FlokiNET support)
[ ] Docker + stack deploy               deploy.sh ‚Üí compose-production.yml up
[ ] LND signet wallet                   create wallet, fund via signet faucet, open channel
    - decision: signet first, flip to mainnet when confident
[ ] Mint 1 operational                  co-located on founder VPS (Romania)
[ ] Mint 2 (remote)                     separate VPS in Malaysia (Shinjiru) or Switzerland (COIN.HOST)
[ ] Mint 3 (remote)                     third jurisdiction ‚Äî add before public announcement
[ ] Seed content upload                 founder uploads Tier 1 + Tier 2 content via CLI
[ ] Shareable URLs                      https://ocdn.is/asset/<root> returns content
[ ] Monitoring                          uptime check, LND balance alerts, disk usage
[ ] Backup cron                         schedule scripts/backup.sh every 6h
[ ] Multi-endpoint client config        CLI + node-agent: endpoints[] array, retry-with-rotation
[ ] Hardcoded bootstrap list            founder endpoints built into CLI binary
[ ] .onion address                      Tor hidden service in compose-production.yml
[ ] Second domain                       separate registrar/TLD pointing to same or different IP
[ ] peers.json rolling cache            ~/.dupenet/peers.json updated on every successful interaction
[ ] Daily Bitcoin anchoring (L7)        1 tx/day, Taproot tweak, epoch_summary + snapshot hash
    - infrastructure side; UI verify page + crisis readiness in Sprint 7e

Exit: public URL serves real content via L402. External client can `dupenet fetch` from anywhere.
      Client survives founder endpoint outage via retry-with-rotation + cache + .onion fallback.
      Daily Bitcoin anchor makes all protocol state verifiable. Crisis spike degrades gracefully.

## Sprint 9 ‚Äî Multi-host (prove the network)

Second host connects to the founder's coordinator and mirrors content.
DocRef: MVP_PLAN:¬ßNode Kit (Target: Raspberry Pi), ¬ßBounty Pool Mechanics

[ ] Second VPS (or Pi)                  deploy compose-nodekit.yml pointing at founder coordinator
[ ] Node-agent mirrors content          agent discovers bounty feed, mirrors top CIDs from founder gateway
[ ] Directory shows 2 hosts             GET /directory lists both with pricing + availability
[ ] Spot-checks pass                    coordinator verifies second host has blocks (GET /spot-check)
[ ] Failover works                      kill host 1 ‚Üí client retries host 2 ‚Üí content still available
[ ] CLI host selection                  `dupenet fetch` picks cheapest/fastest host from directory
[ ] Receipt flow from second host       L402 fetch from host 2 ‚Üí receipt ‚Üí epoch settlement includes both hosts

Exit: two independent hosts serve the same CID. Kill one, content survives. Receipts flow from both.


================================================================================
PATH A.1: EventV1 + REFERENCE MATERIALIZER (no VPS dependency ‚Äî build while waiting)
================================================================================

Goal: collapse all non-blob, non-receipt protocol actions into EventV1 envelope.
Build reference materializer that interprets kind bytes. Content becomes discoverable,
fundable, and discussable via one endpoint (POST /event) and one query (GET /events).
DocRef: MVP_PLAN:¬ßProtocol vs Materializer Boundary, ¬ßEvent Layer, ¬ßEvent Kind Payload Conventions

Architectural decision (2025-02-08):
  - Protocol surface area is the enemy. Proof-of-service is sacred. Everything else is views.
  - EventV1 { v, kind, from, ref, body, sats, ts, sig } is the only non-blob protocol primitive.
  - Protocol rule: if event.sats > 0, credit pool[event.ref] += sats. That's it.
  - Kind interpretation, threading, ranking, author rewards, pin lifecycle, moderation = materializer.
  - Tip / upvote / fortify / pin are all the same action: POST /event with sats > 0.
  - Pins are kind=PIN_POLICY events with drain policy in body. Materializer enforces SLA.
  - Author earnings: not in protocol. Authors self-host (earn as hosts) or earn via materializer bonuses.
  - Existing POST /tip, POST /host/register, POST /content/announce ‚Üí collapse into POST /event.
  - ReceiptV2 + epoch settlement untouched. Don't fix what's not broken.

## Sprint 7b ‚Äî EventV1 Envelope (packages/physics)

The protocol-level event primitive. Everything in materializer depends on this.
ALSO: fixes all divergences marked "Sprint 7b" in ¬ßDIVERGENCES above.

[x] EventV1 TypeBox schema             { v: u8, kind: u8, from: bytes32, ref: bytes32, body: bytes, sats: u64, ts: u64, sig }
    - canonical serialization (same pattern as existing schemas)
    - event_id = SHA256(canonical(EventV1 minus sig))
    - Ed25519 signature: sign/verify canonical(EventV1 minus sig)
    - body: hex-encoded CBOR, inline ‚â§16 KiB (kind-specific payload)
    - sats: economic weight (0 = free statement, >0 = pool credit)
    - packages/physics/src/schemas/event.ts + packages/physics/src/event-v1.ts
[x] Kind byte constants                0x01 FUND, 0x02 ANNOUNCE, 0x03 POST, 0x04 HOST, 0x05 REFUSAL,
                                       0x06 ATTEST, 0x07 LIST, 0x08 PIN_POLICY, 0x09 MATERIALIZER
    - packages/physics/src/constants.ts: EVENT_KIND_* constants
[x] Kind payload schemas (TypeBox)     AnnouncePayload, HostPayload, ListPayload, PinPayload
    - these are materializer conventions, not protocol ‚Äî live under physics for convenience
    - unknown kinds: preserve, don't reject (extensibility)
    - AnnouncePayload.access: "open" | "paid" (default "paid") ‚Äî publisher intent for open-access serving
      "open" = full content served without L402 (hosts earn from bounty pool only)
      materializer renders inline vs behind paywall based on this field
      see MVP_PLAN:¬ßNew User Journey (First Contact), ¬ßOpen Access Tier
[x] PricingV1.open_min_pool_sats       DONE (added in prior sprint) ‚Äî already in TypeBox schema + constants
    - pool below threshold ‚Üí host declines open-access, falls back to L402
    - prevents free-CDN abuse: open access is sponsored availability, not charity
    - default: 500 sats (OPEN_MIN_POOL_SATS_DEFAULT in constants)
[x] Pool credit rule                   if event.sats > 0: credit pool[event.ref] += sats (minus royalty)
    - pool_key = event.ref (bytes32 ‚Äî can be CID, event_id, topic hash)
    - protocol is key-blind; materializer resolves ref ‚Üí CID for settlement
    - implemented in POST /event handler (apps/coordinator/src/server.ts)
[x] EventV1 tests                      24 tests: construct, sign, verify, event_id, body encode/decode, kind constants
    - packages/physics/test/vectors/event-v1.test.ts
[x] Migrate existing events            POST /event accepts all kinds; POST /tip + POST /host/register remain as shims
    - backward compat: existing POST /tip, POST /host/register still work
    - new canonical path: POST /event (accepts any kind)
    - kind=HOST events trigger host registration as materializer side effect

Divergence fixes (bundled into this sprint ‚Äî see ¬ßDIVERGENCES):
[x] Replace fee model                  DONE ‚Äî royalty.ts + bounty-pool.ts + constants.ts. 170/170 tests pass.
[x] PricingV1 complete                 DONE ‚Äî 4 new Optional fields in TypeBox schema. Constants added.
[x] New constants                      DONE ‚Äî EVENT_MAX_BODY, MAX_LIST_ITEMS, FREE_PREVIEW_MAX_BYTES, EVENT_POW_TARGET.
[x] Pool key ‚Üí bytes32                 Prisma BountyPool.cid ‚Üí poolKey (@map("cid") preserves column).
    - bounty-pool.ts, epoch-settlement.ts, server.ts, all tests updated
    - pool key accepts any bytes32: CID, event_id, topic hash
[x] GET /cid/:hash endpoint            gateway: if asset ‚Üí 302 /asset/; if file ‚Üí 302 /file/; if block ‚Üí serve bytes.
    - apps/gateway/src/routes/cid.ts: nano-blob path for events ‚â§ CHUNK_SIZE
[x] Free preview tier                  blocks ‚â§ FREE_PREVIEW_MAX_BYTES (16 KiB) served without L402.
    - apps/gateway/src/routes/block.ts: check before L402 gate
    - configurable: FREE_PREVIEW_ENABLED env var (default true)
    - L402 tests disable preview to exercise paid flow
[ ] BASE_FEE                           21-210 sats (dynamic, EIP-1559 style) ‚Äî EventV1 ingest pricing.
[x] Node-agent publishes min_bounty_sats  in PricingV1 during host registration.
    - apps/node-agent/src/config.ts: AGENT_MIN_BOUNTY_SATS, AGENT_OPEN_MIN_POOL_SATS
    - apps/node-agent/src/announce.ts: includes min_bounty_sats + open_min_pool_sats in pricing

Exit: physics exports EventV1. Construct event, sign, verify. Pool rule tested.
      Kind payloads constructable/verifiable. One envelope replaces per-action schemas.
      Fee model is volume-tapering royalty, not flat 5%. Pool keys accept any bytes32.
      Gateway serves nano-blobs via GET /cid/:hash. Free preview tier works.
      PricingV1 has all 6 fields.

## Sprint 7c ‚Äî Batch Upload + Content Metadata (apps/cli)

The whistleblower flow: upload a directory of PDFs with human-readable metadata.
All publishing now goes through POST /event with appropriate kind bytes.

[x] `dupenet upload <dir>`              batch upload: chunk + upload each file in directory
    - recursive traversal (sorted, skips hidden files), filters by known MIME extensions
    - progress: [N/M] filename, blocks: X/Y (Z%), cached count
    - skip already-uploaded blocks (409 Conflict = ok, resume on failure)
    - per-file ANNOUNCE event (title = relative path, inherits --tags/--access)
    - after all uploads: POST kind=LIST event for collection (items = all asset_roots)
    - error handling: failed files logged, remaining files continue
    - summary: uploaded X/Y files (size, blocks)
[x] Upload metadata + ANNOUNCE          `dupenet upload` now emits ANNOUNCE event after asset upload
    - --title, --tags, --access open|paid flags
    - ANNOUNCE body: title, mime, size, access, tags (CBOR-encoded)
    - graceful fallback: if no keys or coordinator down, upload still succeeds
[ ] Thumbnail generation                generate preview thumbnails client-side (images: 200px JPEG; text: 500 char excerpt)
[x] `dupenet fund <ref> <sats>`         POST /event kind=FUND ‚Üí pool credit
    - works for any ref: CID, event_id, topic hash
    - prints event_id, pool_credit, royalty
[x] `dupenet post <ref> <text>`         POST /event kind=POST ‚Üí threaded reply
    - ref = parent event_id (reply) or topic hash (root post)
    - body = CBOR-encoded { text } ‚â§16 KiB
    - optional --sats flag to boost own post

Exit: `dupenet upload ~/leak/ --title "Court Filings" --tags epstein,legal`
      ‚Üí uploads 200 PDFs, publishes ANNOUNCE + LIST events, prints collection URL.
      `dupenet fund <list_event_id> 10000` ‚Üí credits pool. One endpoint.
      `dupenet post <event_id> "This proves X"` ‚Üí threaded reply published.

## Sprint 7d ‚Äî Signal Aggregation + Market Quoting (apps/coordinator ‚Äî reference materializer)

Materializer views over EventV1 stream. These are product features, not protocol.
All endpoints are materializer conventions ‚Äî other materializers may offer different views.

[x] POST /event                         DONE in Sprint 7b ‚Äî validates EventV1, credits pool, stores in event log
    - now also stores in indexed ProtocolEvent table (Sprint 7d)
    - rate-limit per pubkey/IP deferred (sufficient at founder scale)
[x] GET /events?ref=&kind=&from=&since= generic event query ‚Äî all filters optional, AND-combined, newest first
    - apps/coordinator/src/views/materializer.ts: queryEvents()
[x] Prisma model: ProtocolEvent         { id, eventId, kind, from, ref, body, sats, ts, sig }
    - indexes: (ref), (kind, ts), (from, ts), (event_id unique)
    - separate from generic Event log ‚Äî this is the queryable materializer view
[x] GET /feed/recent                    recent ANNOUNCE events (paginated, filterable by tags)
    - decodes CBOR body ‚Üí title, description, tags, mime, size, access
[x] GET /feed/funded                    pool_keys ranked by balance + ANNOUNCE metadata enrichment
    - host_count per pool key, most recent ANNOUNCE decoded for metadata
[ ] GET /host/:pubkey/scorecard         host reputation (from HOST events + spot-checks + receipts)
[ ] GET /content/:ref/signals           content resilience + graph importance (dual score)
[ ] GET /author/:pubkey/profile         pseudonymous reputation (events by pubkey + demand on their content)
[ ] GET /market/quote                   supply curve from host min_bounty_sats thresholds
[x] GET /thread/:event_id               thread tree: recursive ref-chain resolution from POST events
    - depth-limited (default 10), builds in-memory tree, sorted oldest-first
[ ] GET /cluster/:ref?hops=N            graph neighborhood: all nodes within N hops via ref/body/list edges
[ ] Body edge extraction                parse [ref:bytes32] tokens from POST/ANNOUNCE bodies at ingest
    - Prisma model: BodyEdge { source_event_id, target_ref, edge_sats }
    - index: (target_ref) for inbound citation queries
[ ] Graph importance computation        weighted PageRank over citation DAG (ref + body + list edges)
    - incremental: recompute affected neighborhoods on new events
    - expose via GET /content/:ref/signals (graph_importance field)
[ ] Event-to-blob promotion             funded events above threshold serialized as CIDs ‚Üí PUT /block
    - materializer policy: threshold configurable (e.g. 1000 sats)
    - promoted events enter normal replication market
[ ] GET /orphans                        three-part orphan score: high direct pool + low graph connectivity
                                       (few inbound ref/body edges from funded events) + low discussion depth
                                       (few/zero kind=POST replies). "Funded, but under-analyzed." Analyst job board.
                                       Hard to game: inflating pool costs real sats, reducing connectivity means
                                       not linking to the node (defeats visibility gaming).

Exit: POST /event accepts all kinds. GET /events returns filtered stream.
      GET /feed/funded ranks by dual score (direct pool + graph importance).
      GET /cluster/<ref> returns citation neighborhood. GET /orphans surfaces undiscussed funded content.
      GET /thread/<id> returns discussion tree. Signal endpoints are materializer views ‚Äî not protocol.

## Sprint 7d.1 ‚Äî Event Log Compaction + Snapshot Bootstrap (packages/physics + apps/coordinator)

Unchanged in scope. Snapshots now cover pools (keyed by ref) instead of bounty pools (keyed by CID).
DocRef: MVP_PLAN:¬ßEvent Log Growth + Compaction, ¬ßLongevity L7

[ ] StateSnapshotV1 schema             physics: epoch, merkle roots for pools / hosts / events / serves, event_count, prev_hash
[ ] Merkle tree library                physics: build from sorted key-value pairs, generate/verify inclusion proofs
[ ] Snapshot generator                 coordinator: materialize Prisma state into StateSnapshotV1
[ ] GET /snapshot/latest, GET /snapshot/:epoch, GET /snapshot/:epoch/proof/:key
[ ] Receipt rollup in epoch settlement EpochSummary stores receipt merkle_root + counts only
[ ] GET /bootstrap                     fast node sync: latest snapshot + events since
[ ] Snapshot verification              publisher sig (MVP), Bitcoin-anchored epoch root (L7)
[ ] Snapshot + inclusion proof tests

Exit: GET /bootstrap returns snapshot + recent events. New node materializes in seconds.

## Sprint 7e ‚Äî The Leaderboard + Web Surface (the product)

The global importance scoreboard ‚Äî content ranked by economic commitment. The product that
drives adoption, distribution, funding, and institutional revenue. The new user journey
(MVP_PLAN:¬ßNew User Journey) lives or dies here.
DocRef: MVP_PLAN:¬ßThe Leaderboard (Step 8), ¬ßNew User Journey (First Contact)

### Minimum ship (4 pages + interaction) ‚Äî DONE

[x] Scaffold web app                   apps/web, Next.js 15, App Router, server + client components
    - monospace system font, no CSS framework, minimal client JS (~3 kB per interactive page)
    - API client: src/lib/api.ts (server-side), src/lib/event-client.ts (client-side)
    - revalidate=30s server-side caching, router.refresh() after user actions

[x] / Leaderboard
    - network stats header: item count, ‡∏ø total sats, üíø active hosts
    - table: rank #, ‡∏ø sats, üíø hosts, title (linked), üîç proof link
    - IdentityChip in header (float right)
    - symbols as column headers (‡∏ø üíø üîç), no text labels
    - (deferred: SSE live updates, velocity indicators, inline +‡∏ø per row)

[x] /v/<ref> Content page
    - title, author ¬∑ date, description, [tags]
    - instrument cluster: ‡∏ø sats  ìÄ† funders  üíø copies  ‚ó∑ ~Nmo  ‚óè paid/‚óã open
    - +‡∏ø fortify ¬∑ ‚§ì download ¬∑ üîç proof
    - activity pulse: +‡∏ø210 ab12 3m ¬∑ üí¨ cd34 1h (recent fund/post events)
    - üí¨ N thread count + nested replies (from ¬∑ sats ¬∑ Nago)
    - üí¨ comment box
    - GET /content/:ref/stats ‚Äî one-call aggregated stats for cluster
    - (deferred: inline render for open-access, SSE counter, collection back-link)

[x] /c/<list> Collection page
    - title, item count, author, date, description
    - table: ‡∏ø balance per item, ref link, üîç proof link
    - pool balance fetched per item via GET /bounty/:ref
    - (deferred: Fund All flow, collection item sizes)

[x] /p/<ref> Proof page
    - hash + "sha256"
    - instrument cluster: ‡∏ø sats  ìÄ† funders  üíø copies  ‚Üª last payout epoch
    - üíø N trusted hosts table: endpoint, pk, score
    - ‚úì N epoch proofs table: epoch, host, rcpt, clt, ‡∏ø reward
    - [x] copy hash + copy url buttons (CopyButton component)
    - [x] ‚§ìjson evidence bundle download (GET /api/evidence/:ref)
    - (deferred: Bitcoin anchor txid, verify now re-check)

### Screen interaction polish (6-screen model)

1) Read (/v/<ref>)
[x] Collection back-link               if ref appears in LIST event, show ‚óÄ link to /c/<list>

2) Fortify (+‡∏ø)
[x] Amount buttons 210/21k/21m         replace [21,210,2100] with [210,21000,21000000], labels: 210/21k/21m
[ ] Fortify modal/sheet                extract from inline to overlay/bottom-sheet for mobile
    - payment pending: spinner (‡∏ø...) + auto-poll 3s, no manual "I paid" button

3) Discuss (üí¨)
[x] Event PoW (Web Worker)             cross-ref: see ¬ßClient interaction model below

4) Explore (/ leaderboard)
[ ] Inline +‡∏ø on rows                  FortifyButton per leaderboard row (or link to /v/<ref>#+‡∏ø)

5) Fund collection (/c/<list>)
[ ] Fund All flow                      amount input ‚Üí size-weighted split across items ‚Üí N FUND events ‚Üí payment UI
[ ] Collection item sizes              fetch ANNOUNCE metadata for size field per item

6) Verify (/p/<ref>)
[x] Copy proof URL                     copy hash + /p/<ref> URL to clipboard (CopyButton component)
[x] Export evidence bundle             GET /api/evidence/:ref ‚Üí downloadable JSON
    - packages: ref hash, sha256 verification note, pool (balance, funded, funders, last payout),
      hosts (count, trusted list with endpoint/pubkey/score), epoch proofs (last 6)
    - Content-Disposition: attachment; filename="evidence-<ref12>.json"
    - ‚§ìjson link on proof page after hash/url copy buttons
[ ] Verify now                         re-check hash + spot-check endpoints on demand

### Next pass (add after 6-screen loop proves out)

[ ] Topic leaderboards: /topic/<tag>   tag filter on leaderboard, not separate page
[ ] Cluster page: /g/<ref>             graph neighborhood (needs enough edges to be useful)
[ ] Thread page: /t/<event_id>         separate thread view (threads already render on /v/<ref>)
[ ] Thread bundle page: /b/<bundle_cid> archived conversation snapshot
[ ] Orphan filter                      "sort by: needs analysis" on leaderboard (not separate page)
[ ] Host scorecard: /h/<pubkey>        operator-facing, add when there are operators
[ ] Embeddable widget                  distribution mechanism, add after loop is proven
[ ] Velocity indicators, collection sort/filter, inbound/outbound citation counts
[ ] Fund Thread button                 fan-out over ref-chain (cheap to add, but comment+Fortify first)
[ ] Market quote tooltip               "+‡∏ø X ‚Üí est. +Y replicas" on Fortify button

### Client interaction model (MVP_PLAN:¬ßClient Interaction Model)

[x] Browser keypair lifecycle           generate Ed25519 on first write ‚Üí indexedDB + localStorage (pk)
    - src/lib/keys.ts: indexedDB "dupenet" store, localStorage cache for pubkey hex
    - src/components/KeyProvider.tsx: React context, IdentityChip (short pubkey + generate/clear)
    - "no key" mode: read-only browsing, write prompts key creation (1 tap)
    - uses @noble/ed25519 + @noble/hashes (cross-browser, incl. Firefox)
    - (deferred: NIP-07 upgrade, export/import)
[x] Event construction in browser       browser-native crypto, no physics dependency in client bundle
    - src/lib/crypto.ts: minimal deterministic CBOR encoder (RFC 8949 canonical, matches cbor-x)
    - Ed25519 sign via @noble/ed25519, SHA256 via @noble/hashes/sha2
    - EventV1 compose ‚Üí sign ‚Üí POST /api/event proxy ‚Üí coordinator
    - src/lib/event-client.ts: createFundEvent, createPostEvent, postEvent
[x] Fortify button                     amount selector (21/210/2100/custom) ‚Üí sign FUND event ‚Üí POST
    - src/components/FortifyButton.tsx: "use client", amount picker, status feedback
    - on /v/<ref> content page: [fortify] link ‚Üí amount selector ‚Üí send ‚Üí "funded" ‚Üí refresh
    - full payment flow: payreq ‚Üí WebLN auto-pay ‚Üí invoice fallback ‚Üí sign + POST
[x] Comment box                         text input ‚Üí sign POST event (kind=0x03) ‚Üí POST
    - src/components/CommentBox.tsx: "use client", textarea, status feedback
    - ref = root event_id (ANNOUNCE or content ref), thread appears after refresh
[x] API proxy routes                    POST /api/event, POST /api/payreq, GET /api/payreq/:hash
    - keeps coordinator URL server-side, no CORS needed
[x] Page integration                    IdentityChip on leaderboard, FortifyButton + CommentBox on /v/<ref>
    - layout.tsx: KeyProvider wraps all pages
    - page.tsx: IdentityChip in header (float right)
    - v/[ref]/page.tsx: FortifyButton + CommentBox below content
[x] Payment-intent binding              POST /payreq { sats, event_hash } ‚Üí LN invoice bound to event
    - coordinator: POST /payreq creates invoice via LndClient, stores in PaymentStore (10-min TTL)
    - coordinator: GET /payreq/:payment_hash polls LND for settlement status
    - coordinator: POST /event verifies payment (lookupInvoice) before crediting pool
    - dev mode (no LND): sats trusted without payment ‚Äî sufficient at founder scale
    - web: FortifyButton handles 3 tiers:
      1. WebLN auto-pay (window.webln.sendPayment) ‚Üí instant
      2. Invoice string + lightning: URI link ‚Üí manual pay ‚Üí poll for settlement
      3. Dev mode bypass (no invoice, direct sign + POST)
    - src/lib/webln.ts: WebLN type declarations, hasWebLN(), payWithWebLN()
    - apps/coordinator/src/views/payment-store.ts: in-memory store (dual-keyed by event_hash + payment_hash)
[x] Event PoW (Web Worker)             free writes: PoW in Web Worker, never block UI
    - challenge = SHA256("EV1_POW" || from || ts_be64 || kind_u8 || ref || SHA256(body_bytes))
    - find nonce where H(challenge || nonce_be64) < EVENT_POW_TARGET (2^240, ~200ms mobile)
    - physics: buildEventPowChallenge(), verifyEventPow() in event-v1.ts
    - browser: pow-worker.ts (Web Worker, @noble/hashes SHA256), pow.ts (wrapper, fallback to main thread)
    - CommentBox: "üí¨mining..." ‚Üí "üí¨sending..." ‚Üí "üí¨‚úì" (PoW transparent to user)
    - coordinator: REQUIRE_EVENT_POW=true ‚Üí verifies pow_nonce + pow_hash on sats=0 events
    - event payload: pow_nonce (hex16) + pow_hash (hex64) travel alongside signed event (not signed)
[ ] Upload shim (MVP)                  POST /upload (multipart) ‚Üí materializer chunks ‚Üí returns asset_root
    - metadata events (ANNOUNCE/LIST) always signed client-side
    - returns identical objects to client-side chunking (drop-in swap later)
[ ] SSE endpoints                      GET /sse/global (leaderboard), GET /sse/ref/<ref> (per-content)
    - message types: fund_delta, new_event, replica_change, rank_shift
    - optimistic UI insert on submit, reconcile on SSE echo
[ ] Pending event queue                indexedDB: signed events stored offline, replay on reconnection, dedup by event_id
    - connects to ¬ßLongevity L2 (client-side event buffer)

### Fortify payment flow (MVP_PLAN:¬ßNew User Journey ‚Äî zero-to-sats)

[x] +‡∏ø UI + payment flow               amount selector + payreq + WebLN/invoice + sign + POST
[x] WebLN auto-pay (tier 1)            +‡∏ø ‚Üí WebLN.sendPayment() ‚Üí sign event ‚Üí POST ‚Üí 4-pack cycle
[x] Invoice/URI fallback (tier 2)      no WebLN ‚Üí lightning: URI link + copy button ‚Üí poll for settlement
[ ] QR code display                    render QR from bolt11 (add qrcode library when needed)
[ ] Wallet guide (tier 3)              no wallet ‚Üí one-screen guide (Phoenix/Alby). Accept bounce-and-return.
[ ] Fortify abandonment tracking        measure clicks ‚Üí completions per tier. Fiat bridge trigger: >60% abandon.

### Bitcoin integrity anchor (L7 ‚Äî pulled into MVP)

[ ] Daily Bitcoin tx                   Taproot tweak: SHA256(epoch_summary_merkle_root || state_snapshot_hash)
    - batched: 1 tx/day covering 6 epochs. ~$0.50/day.
[ ] Verify page: /verify/<ref>         paste CID or event_id ‚Üí inclusion proof path ‚Üí Bitcoin tx link
    - "integrity radiator" ‚Äî institutions won't touch without it

### Crisis readiness (before first spike)

[ ] Read-only mode                     one switch: disable writes, keep serving reads
[ ] Hot-path cache                     top 100 leaderboard items cached, invalidated on new events
[ ] Rate limiting                      materializer API per-IP (L402 surge pricing at volume)
[ ] Status page                        public uptime/health endpoint + incident comms template
[ ] Graceful degradation               widget and API serve cached data if coordinator overloaded

Exit: 4 pages ship. / shows leaderboard with live SSE updates. /v/<ref> shows content (open-access
      inline, paid behind L402), 3 stats, Fortify (WebLN+QR), comment box. /c/<list> shows collection
      with Fund All. /p/<ref> shows proof with Bitcoin anchor + evidence download.
      New user journey core loop works: arrive ‚Üí read ‚Üí fund ‚Üí comment ‚Üí prove.


================================================================================
PATH B: S3 ADAPTER (platform adoption)
================================================================================

Goal: existing apps switch to dupenet storage with a config change.
DocRef: MVP_PLAN:¬ßS3-Compatible Adapter (Layer A ‚Äî Migration Unlock)

## Sprint 10 ‚Äî S3-compatible adapter (apps/s3-adapter)

Thin shim that speaks S3 protocol and translates to the blob layer.
Single-tenant: runs alongside the consuming app, talks to one gateway.

[ ] Project scaffold                    apps/s3-adapter, TypeScript + Fastify (or http)
[ ] Auth layer                          S3 access key ‚Üí protocol pubkey mapping (thin translation)
    - single-user mode for MVP (one access key)
    - SigV4 signature verification (just enough to satisfy AWS SDKs)
[ ] PUT object ‚Üí chunk + upload         receive S3 PutObject ‚Üí chunk file ‚Üí PUT /block √ó N ‚Üí PUT /file ‚Üí PUT /asset
    - compute asset_root, return as ETag
    - handle multipart uploads (S3 multipart ‚Üí map to block uploads)
    - chunking reuses @dupenet/physics
[ ] GET object ‚Üí resolve + stream       S3 GetObject ‚Üí GET /asset ‚Üí GET /file ‚Üí stream GET /block √ó N
    - reassemble blocks into response stream
    - Range header support (partial reads)
    - Content-Type from AssetRoot mime
[ ] HEAD object                         S3 HeadObject ‚Üí HEAD /asset ‚Üí return size, content-type, ETag
[ ] DELETE object                       return 204 (no-op; content-addressed = no true delete)
[ ] LIST objects                        return list of known asset_roots (local cache)
    - or: return empty (many apps don't need LIST)
[ ] Bucket abstraction                  all objects in one "bucket" (single gateway = single bucket)
[ ] Integration test                    `aws s3 cp` in, `aws s3 cp` out, `aws s3 ls` ‚Üí identical bytes
[ ] Docker image                        add to compose-founder.yml as optional service

Exit: `aws s3 cp file.tar s3://dupenet/file.tar` succeeds.
      `aws s3 cp s3://dupenet/file.tar -` returns identical bytes.
      No code changes in the consuming app.

## Sprint 11 ‚Äî SDK + documentation

Make Layer A consumable by external developers.
DocRef: MVP_PLAN:¬ßReceipt Verification SDK, ¬ßAdoption Path

[ ] receipt-sdk published               npm publish @dupenet/receipt-sdk (zero deps, works everywhere)
[ ] physics published                   npm publish @dupenet/physics (or subset: canonical, cid, chunker)
[ ] HTTP API reference                  OpenAPI/Swagger spec for gateway + coordinator endpoints
    - generated from route definitions or hand-written
    - hosted at docs.dupenet.dev
[ ] Integration guide                   "Store files on dupenet in 5 minutes"
    - code samples: upload, fetch, tip, pin
    - S3 adapter setup guide
[ ] Receipt verification guide          "Verify paid consumption in your app"
    - import receipt-sdk ‚Üí verify receipts ‚Üí rank content / gate access
    - cross-platform use cases (Nostr, forums, media apps)
[ ] Pin contract guide                  "Pay for durability"
    - create pin, monitor copies, cancel/refund flow

Exit: a developer who has never seen the codebase can integrate in <1 hour.


================================================================================
REMAINING POLISH (non-blocking, do when convenient)
================================================================================

[ ] EXIF/metadata stripping             strip before hashing (mentioned in spec, not implemented)
[ ] Runtime schema validation           TypeBox schemas defined but Value.Check not called on ingest
[ ] Stake locking via LND               verify stake payment on host registration (currently stubbed)
[ ] Deterministic Docker builds         Nix flake or pinned multi-stage (DocRef: MVP_PLAN:¬ßLongevity L6)
[ ] Epoch root anchoring                Bitcoin tx per epoch: SHA256(epoch_summary_root || snapshot_hash) (DocRef: MVP_PLAN:¬ßLongevity L7)
    - makes state snapshots trustlessly verifiable (no need to trust coordinator)
    - depends on Sprint 7d.1 (snapshot format must exist first)
    - Taproot tweak or OP_RETURN, ~$0.50/day at 1 tx/day covering 6 epochs

External review fixes (solved ‚Äî applied to mvp_plan.md):
[x] FileManifest merkle_root            real binary Merkle tree (leaf hash + pair hash), not SHA256(concat) (#1)
    - enables inclusion proofs, streaming verification, partial block validation
[x] Stake language: custodial            "deposited with coordinator ‚Äî custodial in MVP" (#4)
    - post-MVP: on-chain UTXO, federation, or DLC-based escrow
[x] Free preview rate limiting           per-IP token bucket (60 burst / 10 sustained); CDN for founder hosts (#6)
    - hosts can disable free tier; MUST rate-limit if enabled
[x] Storage pricing knob                 sats_per_gb_month: u64? added to PricingV1 TypeBox schema (host.ts)
    - enables durability estimation: (bounty - egress_drain) / (storage_cost * size_gb) = months
[x] Pin SLA semantics                    best effort + full refund if min_copies unmet 6 epochs (#10)
    - no PIN_CANCEL_FEE on SLA-triggered cancel; regions relaxable via signed amendment


================================================================================
POST-MVP ASSESSMENT (deferred from external review, assess after launch)
================================================================================

DocRef: MVP_PLAN:¬ßPost-MVP Assessment Queue

[ ] Event spam pricing                 decide: paid ingest (402-gated POST /event) vs rate-limited + PoW
    - MVP: materializer rate-limits per pubkey/IP (sufficient at founder scale)
    - POST kind=POST (threaded comments) especially needs friction: PoW min, optional sats
    - assess once real event volume + abuse patterns visible
    - paid ingest funds materializers (product toll, not protocol toll)
    - PoW per event acceptable for humans; evaluate impact on automated publishers

[ ] min_bounty_sats quote gaming       compute behavioral thresholds from HostServe event data
    - MVP: founder knows all hosts, gaming irrelevant
    - post-MVP: observed_threshold = min bounty at which host first served a CID
    - show confidence intervals (self-reported vs observed) when data sufficient
    - separately evaluate slashable signed quotes (expands slash surface beyond crypto fraud)
    - trigger: host count > 50 and supply curve UI is live

[ ] Multi-source parallel download     client fetches blocks from multiple hosts simultaneously
    - MVP: single-host fetch with failover (sufficient for 2-3 hosts)
    - protocol already supports it (block-level addressing + multiple hosts per CID)
    - deferred: partial-file payment economics, block availability bitmap, stripe strategy
    - trigger: 3+ hosts serve the same CID in production

[ ] Receipt privacy (ephemeral pubkeys) clients SHOULD use one-time keypairs for receipt submission (#5)
    - receipt submission already opt-in; casual readers (L402 only) have no protocol exposure
    - ephemeral pubkeys don't weaken anti-sybil: hard defense is economic (L402 cost + mint token),
      not identity-based (key generation is free; PoW escalation per-pubkey already trivially bypassed)
    - RECEIPT_MIN_UNIQUE=3 is a tripwire, not a wall (3 throwaway keys cost zero)
    - lean on payment-based diversity signals: distinct payment_hash, temporal spread, graph breadth
    - aggregator remains MVP privacy trust point (same as all founder dependencies)
    - long-term: blinded/bearer receipts (Cashu-style) for zero-knowledge demand proofs
    - spec updated: MVP_PLAN:¬ßReceipt Privacy (DocRef: MVP_PLAN:¬ßFetch Flow, ¬ßHost Self-Farming)

[ ] Audit griefing hardening            cap frequency, deterministic target selection (#9)
    - cap audit frequency per (host, cid, epoch) ‚Äî prevents bandwidth griefing
    - PRF-based audit target selection (auditable but unpredictable to host)
    - L402 cost already gates spam audits; separate auditor bond adds complexity, defer
    - regional selective failure (honest to auditor IPs, corrupt to others): operational fix (Tor), not protocol fix
    - trigger: audit volume becomes meaningful (>100 audits/day)

[ ] Client safety layer                 layered pre/post-fetch safety, no sandboxing (#11)
    - mirrors operator attestation model (¬ßOperator Content Policy) applied to client side
    - pre-fetch: MIME-type gate (warn on executables/scripts), publisher signal display, CID denylist
    - post-fetch: SHA256 verify (already in spec), magic bytes vs declared MIME, known-good list check
    - ClientPolicyV1 schema: attester_follow, mime_warn, mime_block, trusted_publishers, threshold
      same import/export format as operator policy JSON
    - known-good lists = signed kind=LIST events from projects (code signing via CIDs)
    - encrypted blobs opaque to attesters ‚Äî packs only work for known-flagged unencrypted CIDs
    - out of scope: OS-level sandboxing, content rating, server-side scanning, global blocklist
    - applied to mvp_plan.md: new ¬ßClient Safety Layer section
    - trigger: first malware incident in production

[~] Materializer market + paid ingest   materializers = metadata hosts, same L402 economics (#12 + A)
    - key insight: materializer is a host for metadata ‚Äî ingest events (POST /event),
      serve queries (GET /events, GET /feed, GET /thread). Same L402, same market.
    - EventV1 envelope + kind bytes formalized (2025-02-08 architectural decision)
    - kind=MATERIALIZER event for discovery; MaterializerPayload in kind conventions
    - MVP: founder is sole materializer; free ingest (rate-limited), free queries
    - author rewards = materializer product feature (rebate/bonus from materializer fees), NOT protocol
    - remaining design work (post-MVP, trigger: second materializer operator):
      - relay-vs-materializer economic separation at scale
      - consistency model for divergent materializer state
      - economic tuning: ingest fee vs query fee balance

[ ] Founder service replacement specs   inputs/outputs/swap procedure per service (B)
    - for each: directory, mints, aggregator, snapshots, provisioning, materializer
    - test: can a stranger replace it without "contact the founder"?
    - if not, the longevity section should say so honestly
    - trigger: pre-launch documentation pass


LEGEND: [x] done  [~] partial/stub  [ ] not started
